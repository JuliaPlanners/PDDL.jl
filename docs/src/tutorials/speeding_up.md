# Speeding Up PDDL.jl

By default, PDDL.jl uses the [built-in PDDL interpreter](../ref/interpreter.md) to execute actions, determine the set of available actions, and perform other basic planning operations. However, because the interpreter is not optimized for speed, planning algorithms that use the interpreter are considerably slower than state-of-the-art planners.

```@raw html
<figure style="text-align:center">
    <img src="../../assets/blocksworld-performance-comparison.svg" alt="Blocksworld solution runtimes vs. problem size for PDDL.jl, Pyperplan, and FastDownward, each using A* search with the additive heuristic." width="80%"/>
    <figcaption>Blocksworld solution times for PDDL.jl vs. baselines, each using A* search with the additive heuristic.</figcaption>
</figure>
```

Fortunately, PDDL.jl also provides [a PDDL compiler](../ref/compiler.md) that is optimized for speed and low memory consumption. As can be seen in the (log-scale) graph above, using the compiler to solve Blocksworld problems is 10 times faster than the interpreter, within an order of magnitude of the state-of-the-art [FastDownward](https://www.fast-downward.org/) planner, and 20 times faster than [Pyperplan](https://github.com/aibasel/pyperplan), a Python-based planning system. In this tutorial, we show how to use the PDDL compiler to speed up planning algorithms, and explain how these speed-ups are achieved.

## Using the Compiler

To use the PDDL compiler, all one needs to do is call the [`compiled`](@ref) function on a PDDL domain and problem. A compiled domain and initial state are returned:

```julia
using PDDL, PlanningDomains

# Load a generic representation of PDDL domain and problem
domain = load_domain(:blocksworld)
problem = load_problem(:blocksworld, "problem-10")

# Compile the domain and problem to get a compiled domain and state
c_domain, c_state = compiled(domain, problem)
```

Alternatively, [`compiled`](@ref) can be called on a non-compiled domain and (initial) state:

```julia
# Construct initial state from domain and problem
state = initstate(domain, problem)

# Compile the domain and state to get a compiled domain and state
c_domain, c_state = compiled(domain, state)
```

The compiled outputs `c_domain` and `c_state` can then be used with the [PDDL.jl interface](../ref/interpreter.md), or with [an existing planner from SymbolicPlanners.jl](writing_planners.md#Existing-Planners):

```julia
using SymbolicPlanners

# Call A* search on compiled domain and initial state
goal = PDDL.get_goal(problem)
planner = AStarPlanner(HAdd())
sol = planner(c_domain, c_state, goal)

# Execute resulting plan on the compiled initial state
plan = collect(sol)
for act in plan
    c_state = transition(c_domain, c_state, act)
end

# Check that the goal is achieved in the final state
@assert satisfy(c_domain, c_state, goal)
```

Factoring out the initial cost of [Julia's just-ahead-of-time compilation](https://discourse.julialang.org/t/so-does-julia-compile-or-interpret/56073/2?u=xuan), planning over the compiled domain and state should lead to runtimes that are 10 times faster or more, compared to the PDDL.jl interpreter.

## State Compilation


## Action Compilation


## Compiler Limitations

In the current version of PDDL.jl, the compiler has the following limitations:

  - **Top-level only**: Because [`compiled`](@ref) defines new types and methods, it should only be called at the top-level in order to avoid world-age errors.

  - **Precompilation not supported**: Since [`compiled`](@ref) evaluates code in the `PDDL` module, it will lead to precompilation errors when used in another module or package. Modules which call [`compiled`](@ref) should hence disable precompilation.

  - **Regression not supported**: The compiler does not currently implement the interface functions for reverse action semantics, meaning that it cannot be used for regression search.

  - **Axioms not supported**: The compiler also does not currently support PDDL axioms (a.k.a derived predicates).

  - **No generalization across problems in the same domain**: The compiled code and state representations generated by the compiler currently assume a fixed set of objects. To use the compiler with problems in the same domain, but defined over a different set of of objects the [`compiled`](@ref) function has to be invoked again.

These limitations may eventually be removed in future versions of PDDL.jl.
