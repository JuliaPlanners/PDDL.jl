<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:title" content="Getting Started · PDDL.jl"/><meta name="twitter:title" content="Getting Started · PDDL.jl"/><meta property="description" content="Documentation for the PDDL.jl automated planning library."/><meta property="og:type" content="website"/><meta property="og:image" content="https://juliaplanners.github.io/PDDL.jl/dev/assets/preview-image.png"/><meta property="og:description" content="Documentation for the PDDL.jl automated planning library."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:image" content="https://juliaplanners.github.io/PDDL.jl/dev/assets/preview-image.png?1754525442"/><meta property="twitter:description" content="Documentation for the PDDL.jl automated planning library."/><title>Getting Started · PDDL.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PDDL.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PDDL.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">PDDL.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Loading-Domains-and-Problems"><span>Loading Domains and Problems</span></a></li><li><a class="tocitem" href="#Constructing-and-Inspecting-States"><span>Constructing and Inspecting States</span></a></li><li><a class="tocitem" href="#Executing-Actions-and-Plans"><span>Executing Actions and Plans</span></a></li></ul></li><li><a class="tocitem" href="../writing_planners/">Writing Planners</a></li><li><a class="tocitem" href="../speeding_up/">Speeding Up PDDL.jl</a></li><li><a class="tocitem" href="../extending/">Extending PDDL.jl</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../ref/overview/">Architecture Overview</a></li><li><a class="tocitem" href="../../ref/datatypes/">Concepts and Data Types</a></li><li><a class="tocitem" href="../../ref/interface/">Interface Functions</a></li><li><a class="tocitem" href="../../ref/parser_writer/">Parser and Writer</a></li><li><a class="tocitem" href="../../ref/interpreter/">Interpreter</a></li><li><a class="tocitem" href="../../ref/compiler/">Compiler</a></li><li><a class="tocitem" href="../../ref/absint/">Abstract Interpretation</a></li><li><a class="tocitem" href="../../ref/utilities/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPlanners/PDDL.jl/blob/master/docs/src/tutorials/getting_started.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h1><p>Welcome to using PDDL.jl! This tutorial covers how to install PDDL.jl, how to load your first domain and problem, how to manipulate and inspect states and actions, and how to write and execute a plan that achieves a goal.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>First, download and run Julia, <a href="https://julialang.org/downloads/">available here</a> (version 1.3 or later required). Optionally, <a href="https://pkgdocs.julialang.org/v1/environments/">create your own project</a> and activate its environment. Next, press <code>]</code> in the Julia REPL to enter the package manager, then install the registered version of PDDL.jl by running:</p><pre><code class="nohighlight hljs">add PDDL</code></pre><p>To install the latest development version, you may instead run:</p><pre><code class="nohighlight hljs">add https://github.com/JuliaPlanners/PDDL.jl.git</code></pre><p>PDDL.jl can now be used in the Julia REPL, or at the top of a script:</p><pre><code class="language-julia hljs">using PDDL</code></pre><h2 id="Loading-Domains-and-Problems"><a class="docs-heading-anchor" href="#Loading-Domains-and-Problems">Loading Domains and Problems</a><a id="Loading-Domains-and-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-Domains-and-Problems" title="Permalink"></a></h2><p>PDDL stands for the <a href="https://en.wikipedia.org/wiki/Planning_Domain_Definition_Language">Planning Domain Definition Language</a>, a formal language for specifying the semantics of planning domains and problems. PDDL domain and problem definitions are typically saved as text files with the <code>.pddl</code> extension.</p><h3 id="Loading-Domains"><a class="docs-heading-anchor" href="#Loading-Domains">Loading Domains</a><a id="Loading-Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-Domains" title="Permalink"></a></h3><p>A <strong>PDDL domain</strong> defines the high-level &quot;physics&quot; or transition dynamics of a planning task. A classic example is <a href="https://en.wikipedia.org/wiki/Blocks_world">Blocksworld</a>, a domain where blocks may be stacked on top of each other, or placed on a table:</p><pre><code class="language-lisp hljs">(define (domain blocksworld)
  (:requirements :strips :typing :equality)
  (:types block)
  (:predicates (on ?x ?y - block) (ontable ?x - block) (clear ?x - block)
               (handempty) (holding ?x - block))
  (:action pick-up
   :parameters (?x - block)
   :precondition (and (clear ?x) (ontable ?x) (handempty))
   :effect (and (not (ontable ?x)) (not (clear ?x))
                (not (handempty))  (holding ?x)))
  (:action put-down
   :parameters (?x - block)
   :precondition (holding ?x)
   :effect (and (not (holding ?x)) (clear ?x)
                (handempty) (ontable ?x)))
  (:action stack
   :parameters (?x ?y - block)
   :precondition (and (holding ?x) (clear ?y) (not (= ?x ?y)))
   :effect (and (not (holding ?x)) (not (clear ?y)) (clear ?x)
                (handempty) (on ?x ?y)))
  (:action unstack
   :parameters (?x ?y - block)
   :precondition (and (on ?x ?y) (clear ?x) (handempty) (not (= ?x ?y)))
   :effect (and (holding ?x) (clear ?y) (not (clear ?x))
                (not (handempty)) (not (on ?x ?y))))
)</code></pre><p>Suppose this domain definition is saved in a file named <code>blocksworld.pddl</code> in the current directory. After loading PDDL.jl with <code>using PDDL</code>, we can load the Blocksworld domain by calling <a href="../../ref/parser_writer/#PDDL.Parser.load_domain"><code>load_domain</code></a>:</p><pre><code class="language-julia hljs">domain = load_domain(&quot;blocksworld.pddl&quot;)</code></pre><p>We can then inspect the name of domain, and the list of action names:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_name(domain)
:blocksworld

julia&gt; PDDL.get_actions(domain) |&gt; keys .|&gt; string
4-element Vector{String}:
 &quot;pick-up&quot;
 &quot;unstack&quot;
 &quot;put-down&quot;
 &quot;stack&quot;</code></pre><h3 id="Loading-Problems"><a class="docs-heading-anchor" href="#Loading-Problems">Loading Problems</a><a id="Loading-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-Problems" title="Permalink"></a></h3><p>PDDL domains only define the general semantics of the planning task that apply across any set of objects or goals. To fully define a planning task, we also need to load a <strong>PDDL problem</strong>, which defines an initial state, and a goal to be achieved:</p><pre><code class="language-lisp hljs">(define (problem blocksworld-problem)
  (:domain blocksworld)
  (:objects a b c - block)
  (:init (handempty) (ontable a) (ontable b) (ontable c)
         (clear a) (clear b) (clear c))
  (:goal (and (clear c) (ontable b) (on c a) (on a b)))
)</code></pre><p>In this problem, there are 3 blocks, <code>a</code>, <code>b</code>, and <code>c</code>, which are all initially placed on the table (<code>ontable</code>), with no other blocks placed on them (<code>clear</code>). The goal is to stack the blocks such that <code>c</code> is on <code>a</code> is on <code>b</code>.</p><p>Suppose the problem definition is saved in <code>blocksworld-problem.pddl</code>. We can load it by calling <a href="../../ref/parser_writer/#PDDL.Parser.load_problem"><code>load_problem</code></a>:</p><pre><code class="language-julia hljs">problem = load_problem(&quot;blocksworld-problem.pddl&quot;)</code></pre><p>We can then inspect the list of objects, and the goal to be reached:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_objects(problem) |&gt; println
Const[a, b, c]

julia&gt; PDDL.get_goal(problem) |&gt; write_pddl
&quot;(and (clear c) (ontable b) (on c a) (on a b))&quot;</code></pre><h3 id="Loading-From-A-Repository"><a class="docs-heading-anchor" href="#Loading-From-A-Repository">Loading From A Repository</a><a id="Loading-From-A-Repository-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-From-A-Repository" title="Permalink"></a></h3><p>A wide variety of standard PDDL domains and problems can be found online, such as <a href="https://github.com/potassco/pddl-instances">this repository</a> of instances from the International Planning Competition (IPC). To ease the (down)loading of these domains and problems, the PDDL.jl ecosystem includes <a href="https://github.com/JuliaPlanners/PlanningDomains.jl">PlanningDomains.jl</a>, which contains both a built-in repository of domains and problems, and an interface for accessing domains and problems from other online repositories.</p><p>PlanningDomains.jl can be installed from the Pkg REPL as per usual:</p><pre><code class="nohighlight hljs">add PlanningDomains</code></pre><p>Once installed, we can use PlanningDomains.jl to directly load Blocksworld domains and problems:</p><pre><code class="language-julia hljs">using PlanningDomains

domain = load_domain(:blocksworld)
problem = load_problem(:blocksworld, &quot;problem-2&quot;)</code></pre><p>We can also specify external repositories to download from, such as the previously mentioned repository of <a href="https://github.com/potassco/pddl-instances">IPC domains and problems</a>:</p><pre><code class="language-julia hljs">domain = load_domain(IPCInstancesRepo, &quot;ipc-2000&quot;, &quot;blocks-strips-typed&quot;)
problem = load_problem(IPCInstancesRepo, &quot;ipc-2000&quot;, &quot;blocks-strips-typed&quot;, &quot;problem-2&quot;)</code></pre><h2 id="Constructing-and-Inspecting-States"><a class="docs-heading-anchor" href="#Constructing-and-Inspecting-States">Constructing and Inspecting States</a><a id="Constructing-and-Inspecting-States-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-and-Inspecting-States" title="Permalink"></a></h2><p>Now that we&#39;ve loaded a domain and problem, we can construct the initial state (specified by the problem file) using the <a href="../../ref/interface/#PDDL.initstate"><code>initstate</code></a> function:</p><pre><code class="language-julia hljs">state = initstate(domain, problem)</code></pre><h3 id="Inspecting-Facts-and-Relations"><a class="docs-heading-anchor" href="#Inspecting-Facts-and-Relations">Inspecting Facts and Relations</a><a id="Inspecting-Facts-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-Facts-and-Relations" title="Permalink"></a></h3><p>Conceptually, a <strong>state</strong> consists of a set of objects, and a set of true facts and relations about those objects. We can list the set of facts using <a href="../../ref/datatypes/#PDDL.get_facts-Tuple{State}"><code>PDDL.get_facts</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_facts(state)
Set{Term} with 7 elements:
  clear(a)
  ontable(b)
  clear(b)
  handempty
  ontable(a)
  ontable(c)
  clear(c)</code></pre><div class="admonition is-info"><header class="admonition-header">PDDL vs. Prolog-style syntax</header><div class="admonition-body"><p>Facts are printed in Prolog-style syntax by default: <code>ontable(a)</code> in Prolog is the same as <code>(ontable a)</code> in PDDL. This is because PDDL.jl uses <a href="https://github.com/ztangent/Julog.jl">Julog.jl</a> to represent terms and expressions in first-order logic.</p></div></div><p>In addition to listing facts, we can query the truth value of specific terms using the <a href="../../ref/interface/#PDDL.satisfy"><code>satisfy</code></a> function:</p><pre><code class="language-julia-repl hljs">julia&gt; satisfy(domain, state, pddl&quot;(ontable a)&quot;)
true

julia&gt; satisfy(domain, state, pddl&quot;(on a b)&quot;)
false</code></pre><p>Here, we used the <code>pddl</code> string macro to construct a first-order <a href="../../ref/datatypes/#Julog.Term"><code>Term</code></a>. This allows us to write <code>pddl&quot;(on a b)&quot;</code> as syntactic sugar for the expression <code>Compound(:on, Term[Const(:a), Const(:b)])</code>.</p><p>Besides querying whether particular terms are true or false, we can also ask PDDL.jl to return all satisfying assignments to a logical formula with free variables using the <a href="../../ref/interface/#PDDL.satisfiers"><code>satisfiers</code></a> function:</p><pre><code class="language-julia-repl hljs">julia&gt; satisfiers(domain, state, pddl&quot;(and (ontable ?x) (clear ?x))&quot;)
3-element Vector{Any}:
 {X =&gt; b}
 {X =&gt; a}
 {X =&gt; c}</code></pre><p>Our query <code>pddl&quot;(and (ontable ?x) (clear ?x))&quot;</code> expresses that some object <code>?x</code> is on the table, and is clear (i.e. has no other blocks on top of it), where <code>?x</code> is PDDL syntax for a variable in a <a href="https://en.wikipedia.org/wiki/First-order_logic#Formulas">first-order formula</a>. Since blocks <code>a</code>, <code>b</code> and <code>c</code> all satisfy the query, <a href="../../ref/interface/#PDDL.satisfiers"><code>satisfiers</code></a> returns a list of corresponding variable substitutions. Note that the PDDL variable <code>?x</code> gets rendered in Prolog-style syntax as a capital <code>X</code>, by the convention in Prolog that capital letters refer to variables.</p><h3 id="Inspecting-Non-Boolean-Fluents"><a class="docs-heading-anchor" href="#Inspecting-Non-Boolean-Fluents">Inspecting Non-Boolean Fluents</a><a id="Inspecting-Non-Boolean-Fluents-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-Non-Boolean-Fluents" title="Permalink"></a></h3><p>PDDL is not limited to domains where object properties and relations must have Boolean values. For example, the <a href="https://github.com/potassco/pddl-instances/blob/master/ipc-2002/domains/zenotravel-numeric-automatic/domain.pddl">Zeno Travel domain</a> includes numeric properties and relations, such as the distance between two cities, or the amount of fuel in a plane. We can construct and inspect a state in this domain as well:</p><pre><code class="language-julia hljs">zt_domain = load_domain(:zeno_travel)
zt_problem = load_problem(:zeno_travel, &quot;problem-1&quot;)
zt_state = initstate(zt_domain, zt_problem)</code></pre><p>To inspect all properties and relations (Boolean or otherwise) in this state, we can iterate over the list of pairs returned by <a href="../../ref/datatypes/#PDDL.get_fluents-Tuple{State}"><code>PDDL.get_fluents</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_fluents(zt_state) |&gt; collect
13-element Vector{Pair}:
  at(plane1, city0) =&gt; true
 at(person1, city0) =&gt; true
    onboard(plane1) =&gt; 0
  slow-burn(plane1) =&gt; 4
                    ⋮
       fuel(plane1) =&gt; 3956
  fast-burn(plane1) =&gt; 15
 zoom-limit(plane1) =&gt; 8
   capacity(plane1) =&gt; 10232</code></pre><p>These properties and relations are called <a href="https://en.wikipedia.org/wiki/Fluent_(artificial_intelligence)"><strong>fluents</strong></a>, a term historically used in AI research to describe facts about the world that may change over time.</p><p>Fluents are sometimes also called &quot;state variables&quot;, but we avoid that terminology to prevent confusion with variables in the context of first-order terms and formulae. In keeping with the terminology of <a href="https://en.wikipedia.org/wiki/First-order_logic">first-order logic</a>, Boolean fluents such as <code>(at ?plane ?city)</code> are also called <strong>predicates</strong>, and non-Boolean fluents such as <code>(fuel ?plane)</code> are called <strong>functions</strong> (because they map objects to values).</p><div class="admonition is-info"><header class="admonition-header">Omitted Predicates</header><div class="admonition-body"><p>For conciseness, some implementations of the PDDL.jl interface will omit predicates that are false from the list returned by <a href="../../ref/datatypes/#PDDL.get_fluents-Tuple{State}"><code>PDDL.get_fluents</code></a>, as is the case above.</p></div></div><p>In addition to listing fluents, we can evaluate specific fluents using the <a href="../../ref/interface/#PDDL.evaluate"><code>evaluate</code></a> function. Below, we query the amount of fuel in <code>plane1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; evaluate(zt_domain, zt_state, pddl&quot;(fuel plane1)&quot;)
3956</code></pre><p>We can also evaluate compound expressions of multiple fluents. For example, we might be curious to know the amount of additional fuel that <code>plane1</code> can hold. As syntactic sugar for <code>evaluate(domain, state, term)</code>, we can also use the syntax <code>domain[state =&gt; term]</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; evaluate(zt_domain, zt_state, pddl&quot;(- (capacity plane1) (fuel plane1))&quot;)
6276

julia&gt; zt_domain[zt_state =&gt; pddl&quot;(- (capacity plane1) (fuel plane1))&quot;]
6276</code></pre><p>For <em>non-compound</em> expressions stored directly in the state, we can use <a href="../../ref/datatypes/#PDDL.get_fluent-Tuple{State, Term}"><code>PDDL.get_fluent</code></a> to look up the value of a <code>term</code> in <code>state</code>, or <code>state[term]</code> for short:</p><pre><code class="language-julia-repl hljs">julia&gt; state[pddl&quot;(on a b)&quot;] # Blocksworld query
false

julia&gt; zt_state[pddl&quot;(fuel plane1)&quot;] # Zeno Travel query
3956</code></pre><h3 id="Inspecting-Objects-and-Object-Types"><a class="docs-heading-anchor" href="#Inspecting-Objects-and-Object-Types">Inspecting Objects and Object Types</a><a id="Inspecting-Objects-and-Object-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-Objects-and-Object-Types" title="Permalink"></a></h3><p>Since PDDL states consist of sets of (optionally typed) objects, PDDL.jl provides the <a href="../../ref/datatypes/#PDDL.get_objects-Tuple{State}"><code>PDDL.get_objects</code></a> function to list all objects in a state, as well as all objects of particular type:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_objects(state) |&gt; println # Blocksworld objects
Const[c, a, b]

julia&gt; PDDL.get_objects(zt_state, :aircraft) |&gt; println # Zeno Travel aircraft
Const[plane1]

julia&gt; PDDL.get_objects(zt_domain, zt_state, :movable) |&gt; println # Zeno Travel movables
Const[person1, plane1]</code></pre><p>Note that in the third call to <a href="../../ref/datatypes/#PDDL.get_objects-Tuple{State}"><code>PDDL.get_objects</code></a>, we also provided the domain as the first argument. This is because the domain stores information about the type hierarchy, and the <code>movable</code> type in the Zeno Travel domain is abstract: There are no objects in the state which have the type <code>movable</code>. There only objects of its subtypes, <code>person</code> and <code>aircraft</code>. We can inspect the type hierarchy of a domain using <a href="../../ref/datatypes/#PDDL.get_typetree-Tuple{Domain}"><code>PDDL.get_typetree</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_typetree(zt_domain)
Dict{Symbol, Vector{Symbol}} with 5 entries:
  :object   =&gt; [:movable, :city]
  :movable  =&gt; [:aircraft, :person]
  :aircraft =&gt; []
  :person   =&gt; []
  :city     =&gt; []</code></pre><p>Finally, we can inspect the type of a specific object using <a href="../../ref/datatypes/#PDDL.get_objtype-Tuple{State, Any}"><code>PDDL.get_objtype</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_objtype(zt_state, pddl&quot;(person1)&quot;)
:person</code></pre><h2 id="Executing-Actions-and-Plans"><a class="docs-heading-anchor" href="#Executing-Actions-and-Plans">Executing Actions and Plans</a><a id="Executing-Actions-and-Plans-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-Actions-and-Plans" title="Permalink"></a></h2><p>PDDL domains not only define the predicates and functions which describe a state, but also a set of actions which can modify a state. Having learned how to inspect the contents of a state, we can now modify them using actions.</p><h3 id="Instantiating-Actions"><a class="docs-heading-anchor" href="#Instantiating-Actions">Instantiating Actions</a><a id="Instantiating-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#Instantiating-Actions" title="Permalink"></a></h3><p>In PDDL and symbolic planning more broadly, we distinguish between <strong>action schemas</strong> (also known as <strong>operators</strong>), which specify the general semantics of an action, and <strong>ground actions</strong>, which represent instantiations of actions for specific objects. We can inspect the definition of an action schema in a domain using <a href="../../ref/datatypes/#PDDL.get_action-Tuple{Domain, Symbol}"><code>PDDL.get_action</code></a>, such as the definition of <code>stack</code> below:</p><pre><code class="language-julia-repl hljs">julia&gt; PDDL.get_action(domain, :stack) |&gt; write_pddl |&gt; print
(:action stack
 :parameters (?x ?y - block)
 :precondition (and (holding ?x) (clear ?y) (not (= ?x ?y)))
 :effect (and (not (holding ?x)) (not (clear ?y)) (clear ?x) (handempty) (on ?x ?y)))</code></pre><p>The <code>stack</code> schema has two <strong>parameters</strong> (or arguments) of type <code>block</code>. This means that ground instances of the <code>stack</code> schema have to be applied to two <code>block</code> objects. The schema also specifies a <strong>precondition</strong> formula, which has to hold true in order for the action to be executable (a.k.a. available) in the current state. Finally, the schema contains an <strong>effect</strong> formula, which specifies facts that will either be added or deleted in the next state. In domains with non-Boolean fluents, effects may also assign or modify the values of fluents.</p><p>To refer to a specific application of this action schema to blocks <code>a</code> and <code>b</code> (i.e., a ground action), we can simply write <code>pddl&quot;(stack a b)&quot;</code>, which constructs a <code>Term</code> with <code>stack</code> as its name, and with <code>a</code> and <code>b</code> as arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; pddl&quot;(stack a b)&quot; |&gt; dump
Compound
  name: Symbol stack
  args: Array{Term}((2,))
    1: Const
      name: Symbol a
    2: Const
      name: Symbol b</code></pre><p>If unspecified, whether we are referring to action schemas or ground actions shall be clear from context.</p><h3 id="Listing-Available-Actions"><a class="docs-heading-anchor" href="#Listing-Available-Actions">Listing Available Actions</a><a id="Listing-Available-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#Listing-Available-Actions" title="Permalink"></a></h3><p>For our initial state in the Blocksworld domain, we can iterate over the list of available ground actions (i.e. those with satisfied preconditions) using the <a href="../../ref/interface/#PDDL.available-Tuple{Domain, State, Action, Any}"><code>available</code></a> function:</p><pre><code class="language-julia-repl hljs">julia&gt; available(domain, state) |&gt; collect
3-element Vector{Compound}:
 pick-up(a)
 pick-up(b)
 pick-up(c)</code></pre><p>Note that <a href="../../ref/interface/#PDDL.available-Tuple{Domain, State, Action, Any}"><code>available</code></a> returns an iterator over such actions, so we have to <code>collect</code> this iterator in order to get a <code>Vector</code> result. As before, action <code>Term</code>s are printed in Prolog-style syntax.</p><h3 id="Executing-Actions"><a class="docs-heading-anchor" href="#Executing-Actions">Executing Actions</a><a id="Executing-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-Actions" title="Permalink"></a></h3><p>Since we now know which actions are available, we can <a href="../../ref/interface/#PDDL.execute"><code>execute</code></a> one of them to get another state:</p><pre><code class="language-julia-repl hljs">julia&gt; next_state = execute(domain, state, pddl&quot;(pick-up a)&quot;);

julia&gt; satisfy(domain, next_state, pddl&quot;(holding a)&quot;)
true</code></pre><p>We see that after executing the <code>pddl&quot;(pick-up a)&quot;</code> action, block <code>a</code> is now being held. In contrast, if we try to execute a non-available action, PDDL.jl will throw an error:</p><pre><code class="language-julia-repl hljs">julia&gt; next_state = execute(domain, state, pddl&quot;(stack a b)&quot;);
ERROR: Precondition (and (holding ?x) (clear ?y) (not (= ?x ?y))) does not hold.
⋮</code></pre><p>Instead of using <a href="../../ref/interface/#PDDL.execute"><code>execute</code></a>, we can also use the <a href="../../ref/interface/#PDDL.transition"><code>transition</code></a> function. For domains written in standard PDDL, these functions have the same behavior, but there are extensions of PDDL which include events and processes that are handled by <a href="../../ref/interface/#PDDL.transition"><code>transition</code></a> only. Note that both <a href="../../ref/interface/#PDDL.execute"><code>execute</code></a> and <a href="../../ref/interface/#PDDL.transition"><code>transition</code></a> do not mutate the original state passed in as an argument. For mutating versions, see <a href="../../ref/interface/#PDDL.execute!"><code>execute!</code></a> and <a href="../../ref/interface/#PDDL.transition!"><code>transition!</code></a>.</p><h3 id="Executing-and-Simulating-Plans"><a class="docs-heading-anchor" href="#Executing-and-Simulating-Plans">Executing and Simulating Plans</a><a id="Executing-and-Simulating-Plans-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-and-Simulating-Plans" title="Permalink"></a></h3><p>Now that we know how to execute an action, we can execute a series of actions (i.e. a plan) to achieve our goal in the Blocksworld domain. We can do this by repeatedly calling  <a href="../../ref/interface/#PDDL.transition"><code>transition</code></a>:</p><pre><code class="language-julia hljs">state = initstate(domain, problem)
state = transition(domain, state, pddl&quot;(pick-up a)&quot;)
state = transition(domain, state, pddl&quot;(stack a b)&quot;)
state = transition(domain, state, pddl&quot;(pick-up c)&quot;);
state = transition(domain, state, pddl&quot;(stack c a)&quot;);</code></pre><p>And then check that our goal is indeed satisfied:</p><pre><code class="language-julia-repl hljs">julia&gt; goal = PDDL.get_goal(problem) # Our goal is stack `c` on `a` on `b`
and(clear(c), ontable(b), on(c, a), on(a, b))

julia&gt; satisfy(domain, state, goal)
true</code></pre><p>Rather than repeatedly call <a href="../../ref/interface/#PDDL.transition"><code>transition</code></a>, we can use the <a href="tutorials/@ref"><code>PDDL.simulate</code></a> function to directly simulate the end result of a sequence of actions:</p><pre><code class="language-julia hljs">state = initstate(domain, problem)
plan = @pddl(&quot;(pick-up a)&quot;, &quot;(stack a b)&quot;, &quot;(pick-up c)&quot;, &quot;(stack c a)&quot;)
end_state = PDDL.simulate(EndStateSimulator(), domain, state, plan)</code></pre><p>As before, the goal is satisfied in the final state:</p><pre><code class="language-julia-repl hljs">julia&gt; satisfy(domain, end_state, goal)
true</code></pre><p>The first argument to <a href="tutorials/@ref"><code>PDDL.simulate</code></a> is a concrete instance of a <a href="tutorials/@ref"><code>Simulator</code></a>, which controls what information is collected as the simulation progresses. By default, the first argument is a <a href="tutorials/@ref"><code>StateRecorder</code></a>, which leads <a href="tutorials/@ref"><code>PDDL.simulate</code></a> to return the trajectory of all states encountered, including the first:</p><pre><code class="language-julia-repl hljs">julia&gt; traj = PDDL.simulate(domain, state, plan);

julia&gt; eltype(traj)
GenericState

julia&gt; length(traj)
5</code></pre><p>You&#39;ve now learned how to load PDDL domains and problems, construct and inspect states, and execute (sequences of) actions – congratulations! In the <a href="../writing_planners/">next tutorial</a>, you can learn how to write your very own planning algorithms using the functions introduced here.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« PDDL.jl</a><a class="docs-footer-nextpage" href="../writing_planners/">Writing Planners »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 24 October 2022 23:32">Monday 24 October 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
