<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:title" content="Writing Planners · PDDL.jl"/><meta name="twitter:title" content="Writing Planners · PDDL.jl"/><meta property="description" content="Documentation for the PDDL.jl automated planning library."/><meta property="og:type" content="website"/><meta property="og:image" content="https://juliaplanners.github.io/PDDL.jl/dev/assets/preview-image.png"/><meta property="og:description" content="Documentation for the PDDL.jl automated planning library."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:image" content="https://juliaplanners.github.io/PDDL.jl/dev/assets/preview-image.png?136733922"/><meta property="twitter:description" content="Documentation for the PDDL.jl automated planning library."/><title>Writing Planners · PDDL.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PDDL.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PDDL.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">PDDL.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Writing Planners</a><ul class="internal"><li><a class="tocitem" href="#Forward-Search"><span>Forward Search</span></a></li><li><a class="tocitem" href="#Regression-Search"><span>Regression Search</span></a></li><li><a class="tocitem" href="#Existing-Planners"><span>Existing Planners</span></a></li></ul></li><li><a class="tocitem" href="../speeding_up/">Speeding Up PDDL.jl</a></li><li><a class="tocitem" href="../extending/">Extending PDDL.jl</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../ref/overview/">Architecture Overview</a></li><li><a class="tocitem" href="../../ref/datatypes/">Concepts and Data Types</a></li><li><a class="tocitem" href="../../ref/interface/">Interface Functions</a></li><li><a class="tocitem" href="../../ref/parser_writer/">Parser and Writer</a></li><li><a class="tocitem" href="../../ref/interpreter/">Interpreter</a></li><li><a class="tocitem" href="../../ref/compiler/">Compiler</a></li><li><a class="tocitem" href="../../ref/absint/">Abstract Interpretation</a></li><li><a class="tocitem" href="../../ref/utilities/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Writing Planners</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Writing Planners</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPlanners/PDDL.jl/blob/master/docs/src/tutorials/writing_planners.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Writing-Planners"><a class="docs-heading-anchor" href="#Writing-Planners">Writing Planners</a><a id="Writing-Planners-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-Planners" title="Permalink"></a></h1><p>Using the <a href="tutorials/../ref/interface.md">PDDL.jl interface</a>, it is straightforward to implement planning algorithms which solve problems in PDDL domains. Since all domain and implementation specific details are encapsulated by the interface, the same algorithm can operate across multiple domains, and even multiple representations of the same domain (e.g. <a href="../../ref/interpreter/">interpreted</a> vs. <a href="../../ref/compiler/">compiled</a>).</p><p>In this tutorial, we present two simple planners as examples: forward breadth-first search, and backward breadth-first search.</p><h2 id="Forward-Search"><a class="docs-heading-anchor" href="#Forward-Search">Forward Search</a><a id="Forward-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Search" title="Permalink"></a></h2><p>Our first example is <strong>forward breadth-first search</strong>, shown below. The algorithm accepts a <a href="../../ref/datatypes/#PDDL.Domain"><code>Domain</code></a> and <a href="../../ref/datatypes/#PDDL.Problem"><code>Problem</code></a>, then constructs the initial state with the <a href="../../ref/interface/#PDDL.initstate"><code>initstate</code></a> function. It also extracts the goal formula using <a href="../../ref/datatypes/#PDDL.get_goal-Tuple{Problem}"><code>PDDL.get_goal</code></a>. The algorithm then searches the state space, iteratively expanding the successors of each state and available action in a <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first order</a>:</p><pre><code class="language-julia hljs">function forward_bfs(domain::Domain, problem::Problem)
    # Initialize state and extract goal
    state = initstate(domain, problem)
    goal = PDDL.get_goal(problem)
    # Initialize search queue
    plan = []
    queue = [(state, plan)]
    while length(queue) &gt; 0
        # Pop state and plan
        state, plan = popfirst!(queue)
        # Check if goal is satisfied
        if satisfy(domain, state, goal)
            # Return plan if goal is satisfied
            return plan
        end
        # Iterate over available actions and add successors to queue
        for action in available(domain, state)
            next_state = transition(domain, state, action)
            next_plan = [plan; action]
            push!(queue, (next_state, next_plan))
        end
    end
    # Return nothing upon failure
    return nothing
end</code></pre><p>As can be seen, search proceeds by popping a state and corresponding plan off the search queue at each iteration, then checking if the state satisfies the goal using <a href="../../ref/interface/#PDDL.satisfy"><code>satisfy</code></a>. If the goal is satisfied, the plan is returned. If not, the state is expanded by iterating over each <a href="../../ref/interface/#PDDL.available-Tuple{Domain, State, Action, Any}"><code>available</code></a> action, and constructing the successor state for that action using the <a href="../../ref/interface/#PDDL.transition"><code>transition</code></a> function. The successor state and its corresponding plan are added to queue. Search continues until either the queue is exhausted, or the goal is satisfied.</p><div class="admonition is-info"><header class="admonition-header">Implementation Efficiency</header><div class="admonition-body"><p>While easy to understand, the implementation of breadth-first search presented here is memory inefficient because it stores the plan to each state as part of the search queue. Efficient implementations of planners using breadth-first search should be based off <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Djikstra&#39;s algorithm</a> instead.</p></div></div><h2 id="Regression-Search"><a class="docs-heading-anchor" href="#Regression-Search">Regression Search</a><a id="Regression-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Regression-Search" title="Permalink"></a></h2><p>PDDL.jl also supports planning via <strong>backward search</strong>, also known as <a href="https://artint.info/2e/html/ArtInt2e.Ch6.S3.html"><strong>regression search</strong></a>. Backward search operates by treating the goal condition as a <em>partial</em> or <em>abstract</em> state which only specifies that some predicates must be true. It then searches the space by considering all actions that could possibly achieve the current abstract state (called <strong>relevant</strong> actions), and inverting the semantics of each action (called <strong>regression</strong>). This results in a successor abstract state that represents the pre-image of the action: the set of all states that could have reached the current abstract state through that action.</p><p>A breadth-first version of backward search is shown below.</p><pre><code class="language-julia hljs">function backward_bfs(domain::Domain, problem::Problem)
    # Construct initial state and goal state
    init_state = initstate(domain, problem)
    state = goalstate(domain, problem)
    # Initialize search queue
    plan = []
    queue = [(state, plan)]
    while length(queue) &gt; 0
        # Pop state and plan
        state, plan = popfirst!(queue)
        # Return plan if initial state implies the current abstract state
        if all(evaluate(domain, init_state, fluent) == val
               for (fluent, val) in PDDL.get_fluents(state))
            return plan
        end
        # Iterate over relevant actions and add pre-image to queue
        for action in relevant(domain, state)
            next_state = regress(domain, state, action)
            next_plan = [action; plan]
            push!(queue, (next_state, next_plan))
        end
    end
    # Return nothing upon failure
    return nothing
end</code></pre><p>This algorithm is very similar to <a href="#forward-search"><code>forward_bfs</code></a>: It first constructs an initial state (using <a href="../../ref/interface/#PDDL.initstate"><code>initstate</code></a>) and abstract goal state (using <a href="../../ref/interface/#PDDL.goalstate"><code>goalstate</code></a>) from the domain and problem. It then searches in a breadth-first order from the abstract goal state, iterating over actions that are <a href="../../ref/interface/#PDDL.relevant-Tuple{Domain, State, Action, Any}"><code>relevant</code></a> to achieving the current abstract state, then computing the preimage induced by each action using <a href="../../ref/interface/#PDDL.regress"><code>regress</code></a> and adding the resulting state to the queue. The search terminates when the initial state is found to be in the preimage of some action, i.e., all fluents that are true in the preimage are also true in the initial state.</p><div class="admonition is-info"><header class="admonition-header">Support for Regression Search</header><div class="admonition-body"><p>PDDL.jl currently only provides correct implementations of regression search operations (<a href="../../ref/interface/#PDDL.relevant-Tuple{Domain, State, Action, Any}"><code>relevant</code></a> and <a href="../../ref/interface/#PDDL.regress"><code>regress</code></a>) for STRIPS-style domains. This means that regression search is not currently supported for domains with non-Boolean fluents, negative preconditions, disjunctive preconditions, quantified preconditions, or conditional effects.</p></div></div><h2 id="Existing-Planners"><a class="docs-heading-anchor" href="#Existing-Planners">Existing Planners</a><a id="Existing-Planners-1"></a><a class="docs-heading-anchor-permalink" href="#Existing-Planners" title="Permalink"></a></h2><p>While PDDL.jl makes it relatively easy to implement planning algorithms from scratch, the performance and (re)usability of these algorithms require more careful design. As such, the PDDL.jl ecosystem also includes the <a href="https://github.com/JuliaPlanners/SymbolicPlanners.jl"><strong>SymbolicPlanners.jl</strong></a> library, which provides a wide array of planning algorithms and heuristics that have <a href="https://github.com/JuliaPlanners/SymbolicPlanners.jl#performance">comparable performance</a> to other commonly-used planning systems. Below, we show how to use SymbolicPlanners.jl to solve a Blocksworld problem via <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* search</a> with the <a href="https://doi.org/10.1016/S0004-3702%2801%2900108-4">additive heuristic</a>:</p><pre><code class="language-julia hljs">using PDDL, PlanningDomains, SymbolicPlanners

# Load Blocksworld domain and problem
domain = load_domain(:blocksworld)
problem = load_problem(:blocksworld, &quot;problem-4&quot;)
state = initstate(domain, problem)
goal = PDDL.get_goal(problem)

# Construct A* planner with h_add heuristic
planner = AStarPlanner(HAdd())

# Solve the problem using the planner
sol = planner(domain, state, goal)</code></pre><p>We can check that the resulting solution achieves the goal as desired:</p><pre><code class="language-julia-repl hljs">julia&gt; goal
and(on(d, c), on(c, b), on(b, a), on(a, e))

julia&gt; collect(sol)
10-element Vector{Any}:
 unstack(b, a)
 put-down(b)
 unstack(a, d)
 stack(a, e)
 pick-up(b)
 stack(b, a)
 pick-up(c)
 stack(c, b)
 pick-up(d)
 stack(d, c)

julia&gt; satisfy(domain, sol.trajectory[end], goal)
true</code></pre><p>For more information about the planners and heuristics provided by SymbolicPlanners.jl, consult the <a href="https://github.com/JuliaPlanners/SymbolicPlanners.jl">README</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../speeding_up/">Speeding Up PDDL.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Tuesday 31 May 2022 15:54">Tuesday 31 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
