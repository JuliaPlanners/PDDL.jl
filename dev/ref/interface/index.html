<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface Functions · PDDL.jl</title><meta name="title" content="Interface Functions · PDDL.jl"/><meta property="og:title" content="Interface Functions · PDDL.jl"/><meta property="twitter:title" content="Interface Functions · PDDL.jl"/><meta name="description" content="Documentation for the PDDL.jl automated planning library."/><meta property="og:description" content="Documentation for the PDDL.jl automated planning library."/><meta property="twitter:description" content="Documentation for the PDDL.jl automated planning library."/><meta property="og:url" content="https://juliaplanners.github.io/PDDL.jl/stable/ref/interface/"/><meta property="twitter:url" content="https://juliaplanners.github.io/PDDL.jl/stable/ref/interface/"/><link rel="canonical" href="https://juliaplanners.github.io/PDDL.jl/stable/ref/interface/"/><meta property="og:image" content="https://juliaplanners.github.io/PDDL.jl/stable/assets/preview.png"/><meta property="twitter:image" content="https://juliaplanners.github.io/PDDL.jl/stable/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PDDL.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PDDL.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">PDDL.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../tutorials/writing_planners/">Writing Planners</a></li><li><a class="tocitem" href="../../tutorials/speeding_up/">Speeding Up PDDL.jl</a></li><li><a class="tocitem" href="../../tutorials/extending/">Extending PDDL.jl</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../overview/">Architecture Overview</a></li><li><a class="tocitem" href="../datatypes/">Concepts and Data Types</a></li><li class="is-active"><a class="tocitem" href>Interface Functions</a><ul class="internal"><li><a class="tocitem" href="#Evaluating-Formulae-and-Expressions"><span>Evaluating Formulae and Expressions</span></a></li><li><a class="tocitem" href="#State-Initialization-and-Transition"><span>State Initialization and Transition</span></a></li><li><a class="tocitem" href="#Forward-Action-Semantics"><span>Forward Action Semantics</span></a></li><li><a class="tocitem" href="#Inverse-Semantics"><span>Inverse Semantics</span></a></li></ul></li><li><a class="tocitem" href="../parser_writer/">Parser and Writer</a></li><li><a class="tocitem" href="../interpreter/">Interpreter</a></li><li><a class="tocitem" href="../compiler/">Compiler</a></li><li><a class="tocitem" href="../absint/">Abstract Interpretation</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Interface Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/PDDL.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/PDDL.jl/blob/master/docs/src/ref/interface.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface-Functions"><a class="docs-heading-anchor" href="#Interface-Functions">Interface Functions</a><a id="Interface-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-Functions" title="Permalink"></a></h1><p>PDDL.jl defines a set of interface functions that serve as basic operations in a wide variety of symbolic planning algorithms and applications. These functions are intended to be low-level enough such that planning algorithms can be expressed primarily in terms of the operations they represent, but high-level enough so as to abstract away from implementational details. A schematic overview of most of these interface functions is shown below.</p><div style="text-align:center">
    <img src="../../assets/function-interface.svg" alt="A schematic diagram showing how the PDDL.jl interface functions relate to each other." width="90%"/>
</div><h2 id="Evaluating-Formulae-and-Expressions"><a class="docs-heading-anchor" href="#Evaluating-Formulae-and-Expressions">Evaluating Formulae and Expressions</a><a id="Evaluating-Formulae-and-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-Formulae-and-Expressions" title="Permalink"></a></h2><p>The key distinguishing feature of symbolic planning is the ability to describe and determine whether certain facts about the world hold true (e.g. is the robot holding a block?), or evaluate numeric properties (e.g. the distance between two cities), with queries expressed in terms of first-order logic. As such, PDDL.jl provides the following functions which satisfy or evaluate first-order expressions in the context of a <a href="../datatypes/#PDDL.State"><code>State</code></a>:</p><h3 id="Formula-Satisfaction"><a class="docs-heading-anchor" href="#Formula-Satisfaction">Formula Satisfaction</a><a id="Formula-Satisfaction-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-Satisfaction" title="Permalink"></a></h3><p>Given a term representing a well-formed logical formula, or a collection of <code>terms</code> (treated as conjunctions of such formulae), the <a href="#PDDL.satisfy"><code>satisfy</code></a> function returns whether they are satisfiable within a domain and state:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.satisfy" href="#PDDL.satisfy"><code>PDDL.satisfy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">satisfy(domain::Domain, state::State, term::Term)
satisfy(domain::Domain, state::State, terms::AbstractVector{&lt;:Term})</code></pre><p>Returns whether the queried <code>term</code> or <code>terms</code> can be satisfied in the given <code>domain</code> and <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L10-L16">source</a></section></article><p>When a term has free variables, <a href="#PDDL.satisfy"><code>satisfy</code></a> returns true as long as one satisfying assignment exists. A related function, <a href="#PDDL.satisfiers"><code>satisfiers</code></a>, returns a list of all satisfying assignments to such variables (a.k.a. substitutions), including the empty list when a variable-free formula is satisfied. If no satisfying assignments exist, <code>nothing</code> is returned:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.satisfiers" href="#PDDL.satisfiers"><code>PDDL.satisfiers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">satisfiers(domain::Domain, state::State, term::Term)
satisfiers(domain::Domain, state::State, terms::AbstractVector{&lt;:Term})</code></pre><p>Returns a list of satisfying substitutions of the queried <code>term</code> or <code>terms</code> within the given <code>domain</code> and <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L22-L28">source</a></section></article><h3 id="Term-Evaluation"><a class="docs-heading-anchor" href="#Term-Evaluation">Term Evaluation</a><a id="Term-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Term-Evaluation" title="Permalink"></a></h3><p>Given a term representing a ground expression (i.e. one with no free variables), the <a href="#PDDL.evaluate"><code>evaluate</code></a> function returns the value of that expression in the context of a domain and state:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.evaluate" href="#PDDL.evaluate"><code>PDDL.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate(domain::Domain, state::State, term::Term)</code></pre><p>Evaluates a grounded <code>term</code> in the given <code>domain</code> and <code>state</code>. If <code>term</code> refers to a numeric fluent, the value of the fluent is returned. For logical predicates, <code>evaluate</code> is equivalent to <code>satisfy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L34-L40">source</a></section></article><p>For example, if <code>term</code> refers to a fluent, the value of the fluent is returned. Compound numeric expressions (e.g., the sum of two fluents) can also be evaluated.</p><h2 id="State-Initialization-and-Transition"><a class="docs-heading-anchor" href="#State-Initialization-and-Transition">State Initialization and Transition</a><a id="State-Initialization-and-Transition-1"></a><a class="docs-heading-anchor-permalink" href="#State-Initialization-and-Transition" title="Permalink"></a></h2><p>A PDDL domain specifies the transition dynamics of a first order symbolic model of the world, while a PDDL problem specifies the initial state and object set over which these dynamics are grounded. PDDL.jl thus provides functions for constructing an initial state for a domain and problem, and for simulating the transition dynamics:</p><h3 id="State-Initialization"><a class="docs-heading-anchor" href="#State-Initialization">State Initialization</a><a id="State-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#State-Initialization" title="Permalink"></a></h3><p>Given a domain and problem, the <a href="#PDDL.initstate"><code>initstate</code></a> function returns the initial state, the type of which is concrete subtype of <a href="../datatypes/#PDDL.State"><code>State</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.initstate" href="#PDDL.initstate"><code>PDDL.initstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initstate(domain::Domain, problem::Problem)
initstate(domain::Domain, objtypes[, fluents])</code></pre><p>Construct the initial state for a given planning <code>domain</code> and <code>problem</code>, or from a <code>domain</code>, a map of objects to their types (<code>objtypes</code>), and an optional list of <code>fluents</code>.</p><p>Fluents can either be provided as a list of <code>Term</code>s representing the initial fluents in a PDDL problem, or as a map from fluent names to fluent values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L44-L54">source</a></section></article><p>The type of the returned state may vary depending on the type of the domain or problem provided. For example, providing a compiled domain as an argument leads <a href="#PDDL.initstate"><code>initstate</code></a> to return a compiled state representation.</p><h3 id="State-Transition"><a class="docs-heading-anchor" href="#State-Transition">State Transition</a><a id="State-Transition-1"></a><a class="docs-heading-anchor-permalink" href="#State-Transition" title="Permalink"></a></h3><p>Given a domain, state and action, the <a href="#PDDL.transition"><code>transition</code></a> function returns a successor state, including the effects of events and processes (as supported by <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.5965&amp;rep=rep1&amp;type=pdf">PDDL+</a>) and random sampling (in the case of <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.2335&amp;rep=rep1&amp;type=pdf">probabilistic PDDL</a>). To support future multi-agent extensions of PDDL.jl, <a href="#PDDL.transition"><code>transition</code></a> may also accept a set of <code>actions</code> to be executed in parallel:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.transition" href="#PDDL.transition"><code>PDDL.transition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transition(domain::Domain, state::State, action::Term)
transition(domain::Domain, state::State, actions)</code></pre><p>Returns the successor to <code>state</code> in the given <code>domain</code> after applying a single <code>action</code> or a set of <code>actions</code> in parallel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDDL.transition!" href="#PDDL.transition!"><code>PDDL.transition!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transition!(domain::Domain, state::State, action::Term)
transition!(domain::Domain, state::State, actions)</code></pre><p>Variant of <a href="#PDDL.transition"><code>transition</code></a> that modifies <code>state</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L84-L89">source</a></section></article><h2 id="Forward-Action-Semantics"><a class="docs-heading-anchor" href="#Forward-Action-Semantics">Forward Action Semantics</a><a id="Forward-Action-Semantics-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Action-Semantics" title="Permalink"></a></h2><p>A widely-used strategy in symbolic planning is forward state space search, guided by a planning heuristic. These algorithms are built upon two basic operations to search forward in state space: querying the actions that are available in any given state, and executing an action to generate a successor state. These operations can be performed using the following functions:</p><h3 id="Action-Availability"><a class="docs-heading-anchor" href="#Action-Availability">Action Availability</a><a id="Action-Availability-1"></a><a class="docs-heading-anchor-permalink" href="#Action-Availability" title="Permalink"></a></h3><p>Given a domain, state, action schema and action arguments, the <a href="#PDDL.available-Tuple{Domain, State, Action, Any}"><code>available</code></a> function returns whether the corresponding action is available in the specified state – i.e. its precondition is fulfilled. An action may alternatively be provided as a <a href="../datatypes/#Julog.Term"><code>Term</code></a> (e.g. <code>pddl&quot;(stack a b)&quot;</code>):</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.available-Tuple{Domain, State, Action, Any}" href="#PDDL.available-Tuple{Domain, State, Action, Any}"><code>PDDL.available</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">available(domain::Domain, state::State, action::Action, args)
available(domain::Domain, state::State, action::Term)</code></pre><p>Check if an <code>action</code> parameterized by <code>args</code> can be executed in the given <code>state</code> and <code>domain</code>. Action parameters can also be specified as the arguments of a compound <code>Term</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L95-L102">source</a></section></article><p>When <a href="#PDDL.available-Tuple{Domain, State, Action, Any}"><code>available</code></a> is called without specifying an action, it returns an iterator over all actions available in the specified state, effectively encapsulating the logic for node expansion in a search algorithm:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.available-Tuple{Domain, State}" href="#PDDL.available-Tuple{Domain, State}"><code>PDDL.available</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">available(domain::Domain, state::State)</code></pre><p>Return an iterator over available actions in a given <code>state</code> and <code>domain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L108-L112">source</a></section></article><h3 id="Action-Execution"><a class="docs-heading-anchor" href="#Action-Execution">Action Execution</a><a id="Action-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Action-Execution" title="Permalink"></a></h3><p>Given a domain, state, action schema and action arguments, the <a href="#PDDL.execute"><code>execute</code></a> function returns the result of applying the specified action to the state. An action may also be provided as a <a href="../datatypes/#Julog.Term"><code>Term</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.execute" href="#PDDL.execute"><code>PDDL.execute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">execute(domain::Domain, state::State, action::Action, args)
execute(domain::Domain, state::State, action::Term)</code></pre><p>Execute an <code>action</code> parameterized by <code>args</code> in the given <code>state</code>, returning the resulting state.  Action parameters can also be specified as the arguments of a compound <code>Term</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDDL.execute!" href="#PDDL.execute!"><code>PDDL.execute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">execute!(domain::Domain, state::State, action::Action, args)
execute!(domain::Domain, state::State, action::Term)</code></pre><p>Variant of <a href="#PDDL.execute"><code>execute</code></a> that modifies <code>state</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L134-L139">source</a></section></article><h2 id="Inverse-Semantics"><a class="docs-heading-anchor" href="#Inverse-Semantics">Inverse Semantics</a><a id="Inverse-Semantics-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-Semantics" title="Permalink"></a></h2><p>Regression-based planners (e.g. <a href="https://en.wikipedia.org/wiki/Stanford_Research_Institute_Problem_Solver">the classical STRIPS algorithm</a>) make use of the fact that is possible to plan by working <em>backwards</em> from a goal, repeatedly selecting actions that are relevant to achieving a goal state or specification. This motivates the following interface methods for (i) constructing <em>abstract</em> states from goal specifications and (ii) exposing the <em>inverse</em> semantics of actions:</p><h3 id="Goal-State-Construction"><a class="docs-heading-anchor" href="#Goal-State-Construction">Goal State Construction</a><a id="Goal-State-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Goal-State-Construction" title="Permalink"></a></h3><p>In symbolic planning, a logical goal formula <span>$g$</span> effectively specifies the set of all concrete goal states where <span>$g$</span> holds true. We can represent this set of concrete states as an <em>abstract</em> state <span>$\bar s$</span>. In the special case where the goal <span>$g$</span> contains no disjunctions or functions, <span>$\bar s$</span> can also be understood as a <em>partial</em> state that specifies the values of all predicates in <span>$g$</span>, and leaves all other predicates unspecified.</p><p>To support regression search in this abstract space, PDDL.jl provides the <a href="#PDDL.goalstate"><code>goalstate</code></a> method for constructing an abstract state from the goal specification of a problem:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.goalstate" href="#PDDL.goalstate"><code>PDDL.goalstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">goalstate(domain::Domain, problem::Problem)
goalstate(domain::Domain, objtypes, terms)</code></pre><p>Construct a (partial) goal state from a <code>domain</code> and <code>problem</code>, or from a <code>domain</code>, a map of objects to their types (<code>objtypes</code>), and goal <code>terms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L60-L66">source</a></section></article><p>As with <a href="#PDDL.initstate"><code>initstate</code></a>, the data type of the returned state <span>$\bar s$</span> may depend on the type of domain or problem provided.</p><h3 id="Action-Relevance"><a class="docs-heading-anchor" href="#Action-Relevance">Action Relevance</a><a id="Action-Relevance-1"></a><a class="docs-heading-anchor-permalink" href="#Action-Relevance" title="Permalink"></a></h3><p>Given a domain, state, action schema and action arguments, the <a href="#PDDL.relevant-Tuple{Domain, State, Action, Any}"><code>relevant</code></a> function returns whether the action is relevant to achieving the specified state – i.e., it achieves at least one predicate or numeric constraint in the state, and destroys none through deletion or modification. In the case where the action&#39;s effect reduces to a list of predicates to be added and a list to be deleted, this simplifies to checking that at least one added predicate is true in the state, and that none are deleted. An action may also be provided as a <a href="../datatypes/#Julog.Term"><code>Term</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.relevant-Tuple{Domain, State, Action, Any}" href="#PDDL.relevant-Tuple{Domain, State, Action, Any}"><code>PDDL.relevant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relevant(domain::Domain, state::State, action::Action, args)
relevant(domain::Domain, state::State, action::Term)</code></pre><p>Check if an <code>action</code> parameterized by <code>args</code> is relevant (can lead to) a <code>state</code> in the given <code>domain</code>. Action parameters can also be specified as the arguments of a compound <code>Term</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L150-L157">source</a></section></article><p>When <code>relevant</code> is called without specifying an action, it returns an iterator over all actions relevant to the specified state, encapsulating the logic for node expansion in a regression search algorithm:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.relevant-Tuple{Domain, State}" href="#PDDL.relevant-Tuple{Domain, State}"><code>PDDL.relevant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relevant(domain::Domain, state::State)</code></pre><p>Return an iterator over relevant actions in a given <code>state</code> and <code>domain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L163-L167">source</a></section></article><h3 id="Action-Regression"><a class="docs-heading-anchor" href="#Action-Regression">Action Regression</a><a id="Action-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Action-Regression" title="Permalink"></a></h3><p>Given a domain, state, action schema and action arguments, the <a href="#PDDL.regress"><code>regress</code></a> function executes the action in reverse, returning a (potentially abstract) state that represents the pre-image of the action with respect to the input state. An action may also be provided as a <a href="../datatypes/#Julog.Term"><code>Term</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="PDDL.regress" href="#PDDL.regress"><code>PDDL.regress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regress(domain::Domain, state::State, action::Action, args)
regress(domain::Domain, state::State, action::Term)</code></pre><p>Compute the pre-image of an <code>action</code> parameterized by <code>args</code> with respect to a <code>state</code>. Action parameters can also be specified as the arguments of a compound <code>Term</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDDL.regress!" href="#PDDL.regress!"><code>PDDL.regress!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regress!(domain::Domain, state::State, action::Action, args)
regress!(domain::Domain, state::State, action::Term)</code></pre><p>Variant of <a href="#PDDL.regress"><code>regress</code></a> that modifies <code>state</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/PDDL.jl/blob/17bc764890ee56ab68ccb9fd768ef50e7af27350/src/interface/interface.jl#L189-L194">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datatypes/">« Concepts and Data Types</a><a class="docs-footer-nextpage" href="../parser_writer/">Parser and Writer »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Wednesday 20 December 2023 00:48">Wednesday 20 December 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
