var documenterSearchIndex = {"docs":
[{"location":"ref/absint/#Abstract-Interpretation","page":"Abstract Interpretation","title":"Abstract Interpretation","text":"","category":"section"},{"location":"ref/absint/","page":"Abstract Interpretation","title":"Abstract Interpretation","text":"Coming soon!","category":"page"},{"location":"ref/compiler/#Compiler","page":"Compiler","title":"Compiler","text":"","category":"section"},{"location":"ref/compiler/","page":"Compiler","title":"Compiler","text":"Coming soon!","category":"page"},{"location":"ref/overview/#Architecture-Overview","page":"Architecture Overview","title":"Architecture Overview","text":"","category":"section"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"PDDL.jl differs from standard automated planning systems in that it is designed not only for speed and efficiency, but also extensibility and interoperability. This is due to the fact that the design target of PDDL.jl is an interface, not just a particular algorithm or application. The diagram below provides an overview of the architecture of PDDL.jl and the ecosystem it enables (left), in comparison with the architecture of standard planning systems (right).","category":"page"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"<div style=\"text-align:center\">\n    <img src=\"../../assets/pddl-jl-architecture.svg\" alt=\"A diagram of the architecture and ecosystem of PDDL.jl\" width=\"60%\"/>\n    <img src=\"../../assets/standard-architecture.svg\" alt=\"A diagram of the architecture of a standard planning system\" width=\"30%\"/>\n</div>","category":"page"},{"location":"ref/overview/#Standard-Planning-Architectures","page":"Architecture Overview","title":"Standard Planning Architectures","text":"","category":"section"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"Standard architectures are designed primarily for fast and efficient planning, accepting PDDL domain and problem files as inputs  (right, pink), rapidly translating and compiling them (orange) to more efficient representations (yellow), running planning algorithms and heuristics (blue) over those representations, then producing symbolic plans and metadata as outputs (green). This architecture enables performance optimization over the entire pipeline, but limits interaction with external applications to just two channels: (i) receiving domains and problems as inputs; and (ii) providing plans as outputs.","category":"page"},{"location":"ref/overview/#PDDL.jl-Architecture-and-Ecosystem","page":"Architecture Overview","title":"PDDL.jl Architecture and Ecosystem","text":"","category":"section"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"In contrast, the core of PDDL.jl is its interface (left, green): a set of abstract data types and interface functions that expose the high-level functionality required to implement planning algorithms and applications. Centering PDDL.jl around its interface means that:","category":"page"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"multiple implementations of the interface can coexist (yellow), providing either speed, generality or specialized functionality depending on engineering needs\nmultiple applications (light blue) can use the interface to achieve tighter integration between symbolic planning and other AI components\nmultiple extensions of PDDL are enabled by implementing and extending the interface through additional libraries (dark blue). (Note that the extension libraries shown in the diagram are still under development.)","category":"page"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"By factoring out these components of traditional planning systems into separate software artifacts, PDDL.jl enables an ecosystem where implementations can evolve independently from applications (e.g. through future compiler improvements), applications can interoperate through a common interface (e.g. Bayesian agent models which incorporate planning algorithms), and extensions can be flexibly composed (e.g. multi-agent stochastic domains).","category":"page"},{"location":"ref/overview/#Built-in-Implementations","page":"Architecture Overview","title":"Built-in Implementations","text":"","category":"section"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"Given this interface-centered design, PDDL.jl itself does not include any applications or extensions, which are intended to be provided by separate libraries (e.g. SymbolicPlanners.jl). However, PDDL.jl does include several built-in implementations of its interface: a standard interpreter, a compiler, and an abstract interpreter. Each of these implementations plays a different role in the context of a planning application and its development:","category":"page"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"The standard interpreter is designed to be easily extended, and also comes with the ease of debugging and inspection usually associated with interpreters. As such, it is ideal for checking correctness when specifying a new PDDL domain, or when implementing a planning algorithm or extension library.\nThe compiler enables efficient planning through just-in-time compilation of specialized state representations and action semantics. While compilation is less easy to extend or debug, it provides orders of magnitude speed-ups over interpretation, allowing PDDL.jl applications to scale to much larger problems.\nThe abstract interpreter primary intended use is to compute planning heuristics that rely upon domain relaxation or abstraction. However, abstract interpreters have many other uses which future applications could take advantage of.","category":"page"},{"location":"ref/overview/#Other-Components","page":"Architecture Overview","title":"Other Components","text":"","category":"section"},{"location":"ref/overview/","page":"Architecture Overview","title":"Architecture Overview","text":"In addition to implementations of its interface, PDDL.jl also provides a PDDL parser, writer, and a set of utilities to help analyze and work with PDDL domains. Collectively, these components allow researchers, developers, and engineers to use symbolic planning in a wide variety of application contexts.","category":"page"},{"location":"ref/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"ref/utilities/","page":"Utilities","title":"Utilities","text":"Coming soon!","category":"page"},{"location":"ref/interface/#Interface-Functions","page":"Interface Functions","title":"Interface Functions","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"[(Image: Documentation (Stable))]](https://juliaplanners.github.io/PDDL.jl/dev)","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"<div style=\"text-align:center\">\n    <img src=\"../../assets/function-interface.svg\" alt=\"A schematic diagram showing how the PDDL.jl interface functions relate to each other.\" width=\"90%\"/>\n</div>","category":"page"},{"location":"ref/interface/#Evaluating-Formulae-and-Expressions","page":"Interface Functions","title":"Evaluating Formulae and Expressions","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"The key distinguishing feature of symbolic planning is the ability to describe and determine whether certain facts about the world hold true (e.g. is the robot holding a block?), or evaluate numeric properties (e.g. the distance between two cities), with queries expressed in terms of first-order logic. As such, PDDL.jl provides the following functions which satisfy or evaluate first-order expressions in the context of a State:","category":"page"},{"location":"ref/interface/#Formula-Satisfaction","page":"Interface Functions","title":"Formula Satisfaction","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a term representing a well-formed logical formula, or a collection of terms (treated as conjunctions of such formulae), the satisfy function returns whether they are satisfiable within a domain and state:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"satisfy","category":"page"},{"location":"ref/interface/#PDDL.satisfy","page":"Interface Functions","title":"PDDL.satisfy","text":"satisfy(domain::Domain, state::State, term::Term)\nsatisfy(domain::Domain, state::State, terms::AbstractVector{<:Term})\n\nReturns whether the queried term or terms can be satisfied in the given domain and state.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"When a term has free variables, satisfy returns true as long as one satisfying assignment exists. A related function, satisfiers, returns a list of all satisfying assignments to such variables (a.k.a. substitutions), including the empty list when a variable-free formula is satisfied. If no satisfying assignments exist, nothing is returned:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"satisfiers","category":"page"},{"location":"ref/interface/#PDDL.satisfiers","page":"Interface Functions","title":"PDDL.satisfiers","text":"satisfiers(domain::Domain, state::State, term::Term)\nsatisfiers(domain::Domain, state::State, terms::AbstractVector{<:Term})\n\nReturns a list of satisfying substitutions of the queried term or terms within the given domain and state.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/#Term-Evaluation","page":"Interface Functions","title":"Term Evaluation","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a term representing a ground expression (i.e. one with no free variables), the evaluate function returns the value of that expression in the context of a domain and state:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"evaluate","category":"page"},{"location":"ref/interface/#PDDL.evaluate","page":"Interface Functions","title":"PDDL.evaluate","text":"evaluate(domain::Domain, state::State, term::Term)\n\nEvaluates a grounded term in the given domain and state. If term refers to a numeric fluent, the value of the fluent is returned. For logical predicates, evaluate is equivalent to satisfy.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"For example, if term refers to a fluent, the value of the fluent is returned. Compound numeric expressions (e.g., the sum of two fluents) can also be evaluated.","category":"page"},{"location":"ref/interface/#State-Initialization-and-Transition","page":"Interface Functions","title":"State Initialization and Transition","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"A PDDL domain specifies the transition dynamics of a first order symbolic model of the world, while a PDDL problem specifies the initial state and object set over which these dynamics are grounded. PDDL.jl thus provides functions for constructing an initial state for a domain and problem, and for simulating the transition dynamics:","category":"page"},{"location":"ref/interface/#State-Initialization","page":"Interface Functions","title":"State Initialization","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a domain and problem, the initstate function returns the initial state, the type of which is concrete subtype of State:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"initstate","category":"page"},{"location":"ref/interface/#PDDL.initstate","page":"Interface Functions","title":"PDDL.initstate","text":"initstate(domain::Domain, problem::Problem)\ninitstate(domain::Domain, objtypes[, fluents])\n\nConstruct the initial state for a given planning domain and problem, or from a domain, a map of objects to their types (objtypes), and an optional list of fluents.\n\nFluents can either be provided as a list of Terms representing the initial fluents in a PDDL problem, or as a map from fluent names to fluent values.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"The type of the returned state may vary depending on the type of the domain or problem provided. For example, providing a compiled domain as an argument leads initstate to return a compiled state representation.","category":"page"},{"location":"ref/interface/#State-Transition","page":"Interface Functions","title":"State Transition","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a domain, state and action, the transition function returns a successor state, including the effects of events and processes (as supported by PDDL+) and random sampling (in the case of probabilistic PDDL). To support future multi-agent extensions of PDDL.jl, transition may also accept a set of actions to be executed in parallel:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"transition\ntransition!","category":"page"},{"location":"ref/interface/#PDDL.transition","page":"Interface Functions","title":"PDDL.transition","text":"transition(domain::Domain, state::State, action::Term)\ntransition(domain::Domain, state::State, actions)\n\nReturns the successor to state in the given domain after applying a single action or a set of actions in parallel.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/#PDDL.transition!","page":"Interface Functions","title":"PDDL.transition!","text":"transition!(domain::Domain, state::State, action::Term)\ntransition!(domain::Domain, state::State, actions)\n\nVariant of transition that modifies state in place.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/#Forward-Action-Semantics","page":"Interface Functions","title":"Forward Action Semantics","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"A widely-used strategy in symbolic planning is forward state space search, guided by a planning heuristic. These algorithms are built upon two basic operations to search forward in state space: querying the actions that are available in any given state, and executing an action to generate a successor state. These operations can be performed using the following functions:","category":"page"},{"location":"ref/interface/#Action-Availability","page":"Interface Functions","title":"Action Availability","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a domain, state, action schema and action arguments, the available function returns whether the corresponding action is available in the specified state – i.e. its precondition is fulfilled. An action may alternatively be provided as a Term (e.g. pddl\"(stack a b)\"):","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"available(::Domain, ::State, ::Action, ::Any)","category":"page"},{"location":"ref/interface/#PDDL.available-Tuple{Domain, State, Action, Any}","page":"Interface Functions","title":"PDDL.available","text":"available(domain::Domain, state::State, action::Action, args)\navailable(domain::Domain, state::State, action::Term)\n\nCheck if an action parameterized by args can be executed in the given state and domain. Action parameters can also be specified as the arguments of a compound Term.\n\n\n\n\n\n","category":"method"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"When available is called without specifying an action, it returns an iterator over all actions available in the specified state, effectively encapsulating the logic for node expansion in a search algorithm:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"available(::Domain, ::State)","category":"page"},{"location":"ref/interface/#PDDL.available-Tuple{Domain, State}","page":"Interface Functions","title":"PDDL.available","text":"available(domain::Domain, state::State)\n\nReturn an iterator over available actions in a given state and domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/interface/#Action-Execution","page":"Interface Functions","title":"Action Execution","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a domain, state, action schema and action arguments, the execute function returns the result of applying the specified action to the state. An action may also be provided as a Term:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"execute\nexecute!","category":"page"},{"location":"ref/interface/#PDDL.execute","page":"Interface Functions","title":"PDDL.execute","text":"execute(domain::Domain, state::State, action::Action, args)\nexecute(domain::Domain, state::State, action::Term)\n\nExecute an action parameterized by args in the given state, returning the resulting state.  Action parameters can also be specified as the arguments of a compound Term.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/#PDDL.execute!","page":"Interface Functions","title":"PDDL.execute!","text":"execute!(domain::Domain, state::State, action::Action, args)\nexecute!(domain::Domain, state::State, action::Term)\n\nVariant of execute that modifies state in-place.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/#Inverse-Semantics","page":"Interface Functions","title":"Inverse Semantics","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Regression-based planners (e.g. the classical STRIPS algorithm) make use of the fact that is possible to plan by working backwards from a goal, repeatedly selecting actions that are relevant to achieving a goal state or specification. This motivates the following interface methods for (i) constructing abstract states from goal specifications and (ii) exposing the inverse semantics of actions:","category":"page"},{"location":"ref/interface/#Goal-State-Construction","page":"Interface Functions","title":"Goal State Construction","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"In symbolic planning, a logical goal formula g effectively specifies the set of all concrete goal states where g holds true. We can represent this set of concrete states as an abstract state bar s. In the special case where the goal g contains no disjunctions or functions, bar s can also be understood as a partial state that specifies the values of all predicates in g, and leaves all other predicates unspecified.","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"To support regression search in this abstract space, PDDL.jl provides the goalstate method for constructing an abstract state from the goal specification of a problem:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"goalstate","category":"page"},{"location":"ref/interface/#PDDL.goalstate","page":"Interface Functions","title":"PDDL.goalstate","text":"goalstate(domain::Domain, problem::Problem)\ngoalstate(domain::Domain, objtypes, terms)\n\nConstruct a (partial) goal state from a domain and problem, or from a domain, a map of objects to their types (objtypes), and goal terms.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"As with initstate, the data type of the returned state bar s may depend on the type of domain or problem provided.","category":"page"},{"location":"ref/interface/#Action-Relevance","page":"Interface Functions","title":"Action Relevance","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a domain, state, action schema and action arguments, the relevant function returns whether the action is relevant to achieving the specified state – i.e., it achieves at least one predicate or numeric constraint in the state, and destroys none through deletion or modification. In the case where the action's effect reduces to a list of predicates to be added and a list to be deleted, this simplifies to checking that at least one added predicate is true in the state, and that none are deleted. An action may also be provided as a Term:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"relevant(::Domain, ::State, ::Action, ::Any)","category":"page"},{"location":"ref/interface/#PDDL.relevant-Tuple{Domain, State, Action, Any}","page":"Interface Functions","title":"PDDL.relevant","text":"relevant(domain::Domain, state::State, action::Action, args)\nrelevant(domain::Domain, state::State, action::Term)\n\nCheck if an action parameterized by args is relevant (can lead to) a state in the given domain. Action parameters can also be specified as the arguments of a compound Term.\n\n\n\n\n\n","category":"method"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"When relevant is called without specifying an action, it returns an iterator over all actions relevant to the specified state, encapsulating the logic for node expansion in a regression search algorithm:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"relevant(::Domain, ::State)","category":"page"},{"location":"ref/interface/#PDDL.relevant-Tuple{Domain, State}","page":"Interface Functions","title":"PDDL.relevant","text":"relevant(domain::Domain, state::State)\n\nReturn an iterator over relevant actions in a given state and domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/interface/#Action-Regression","page":"Interface Functions","title":"Action Regression","text":"","category":"section"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"Given a domain, state, action schema and action arguments, the regress function executes the action in reverse, returning a (potentially abstract) state that represents the pre-image of the action with respect to the input state. An action may also be provided as a Term:","category":"page"},{"location":"ref/interface/","page":"Interface Functions","title":"Interface Functions","text":"regress\nregress!","category":"page"},{"location":"ref/interface/#PDDL.regress","page":"Interface Functions","title":"PDDL.regress","text":"regress(domain::Domain, state::State, action::Action, args)\nregress(domain::Domain, state::State, action::Term)\n\nCompute the pre-image of an action parameterized by args with respect to a state. Action parameters can also be specified as the arguments of a compound Term.\n\n\n\n\n\n","category":"function"},{"location":"ref/interface/#PDDL.regress!","page":"Interface Functions","title":"PDDL.regress!","text":"regress!(domain::Domain, state::State, action::Action, args)\nregress!(domain::Domain, state::State, action::Term)\n\nVariant of regress that modifies state in-place.\n\n\n\n\n\n","category":"function"},{"location":"ref/datatypes/#Concepts-and-Data-Types","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"","category":"section"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Symbolic planning is a general term for approaches to automated planning that describe the environment and its dynamics in terms of high-level symbols. PDDL is one way of representing such symbolic knowledge, but there are many related formalisms which the shared concepts of fluents, states, actions, domains, and problems. Here we provide general definitions of these concepts, and also describe the system of data types in PDDL.jl that mirror these concepts. A graphical overview is shown below.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"<div style=\"text-align:center\">\n    <img src=\"../../assets/concepts-datatypes.svg\" alt=\"A graphical overview of concepts in symbolic planning and their corresponding datatypes.\" width=\"80%\"/>\n</div>","category":"page"},{"location":"ref/datatypes/#Fluents-and-Terms","page":"Concepts and Data Types","title":"Fluents and Terms","text":"","category":"section"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Fluents define (relational) state variables which may (or may not) change over time. A fluent of arity n is a predicate (Boolean-valued) or function (non-Boolean) with n object arguments, which describes some property or relation over those objects. A ground fluent is a fluent defined over particular set of objects (i.e. none of its arguments are free variables). Arguments may optionally be type-restricted.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"note: Example\nThe fluent (on ?x ?y) is named on, has arity 2, and describes whether some object denoted by the variable ?x is stacked on top of ?y. The ground fluent (on a b) denotes that object a is stacked on top of object b when true.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"The Term data type is used to represent fluents, but also object constants, variables, logical formulae, effect formulae, and ground actions. Every Term has a name property, as well as an args property, representing the (potentially empty) list of sub-terms it has as arguments. Terms are inherited from the Julog.jl package for Prolog-style reasoning about first-order logic.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Term","category":"page"},{"location":"ref/datatypes/#Julog.Term","page":"Concepts and Data Types","title":"Julog.Term","text":"Julog terms are variables, constants, or compound terms.\n\n\n\n\n\n","category":"type"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"There are three subtypes of Terms:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Const terms, which are used to represent object constants, and have no arguments.\nVar terms are used to represent variables in the context of first-order expressions.\nCompound terms are terms with arguments. They can be used to represent fluents, action preconditions or effects, logical expressions, or ground actions.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"To construct a Term using PDDL syntax, the @pddl macro or pddl\"...\" string macro can be used:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"julia> pddl\"(on a b)\" |> dump\nCompound\n  name: Symbol on\n  args: Array{Term}((2,))\n    1: Const\n      name: Symbol a\n    2: Const\n      name: Symbol b","category":"page"},{"location":"ref/datatypes/#States","page":"Concepts and Data Types","title":"States","text":"","category":"section"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"In symbolic planning, states are symbolic descriptions of the environment and its objects at a particular point in time. Formally, given a finite set of fluents mathcalF, a state s is composed of a set of (optionally typed) objects mathcalO, and valuations of ground fluents mathcalF(mathcalO) defined over all objects in mathcalO of the appropriate types. Each ground fluent thus refers to a state variable. For a ground fluent f in mathcalF(mathcalO), we will use the notation sf = v to denote that f has value v in state s.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"note: Example\nGiven the fluents (on ?x ?y) and (on-table ?x) that describe a state s with objects a and b, there are six ground fluents whose values are defined in the state:  (on a a), (on a b), (on b a), (on b b), (on-table a) and (on-table b). The expression s(on a b) = true means that object a is on top of b in state s.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"In PDDL.jl, states are represented by the State abstract type:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"State","category":"page"},{"location":"ref/datatypes/#PDDL.State","page":"Concepts and Data Types","title":"PDDL.State","text":"State\n\nAbstract supertype for symbolic states. A State is a symbolic description of the environment and its objects at a particular point in time. It consists of a set of objects, and a set of ground fluents (predicates or functions) with values defined over those objects.\n\n\n\n\n\n","category":"type"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"The following accessor methods are defined for a State:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"PDDL.get_objects(::State)\nPDDL.get_objtypes(::State)\nPDDL.get_objtype(::State, ::Any)\nPDDL.get_facts(::State)\nPDDL.get_fluent(::State, ::Term)\nPDDL.set_fluent!(::State, ::Any, ::Term)\nPDDL.get_fluents(::State)","category":"page"},{"location":"ref/datatypes/#PDDL.get_objects-Tuple{State}","page":"Concepts and Data Types","title":"PDDL.get_objects","text":"get_objects(state::State, [type::Symbol])\nget_objects(domain::Domain, state::State, type::Symbol)\n\nReturns an iterator over objects in the state. If a type is specified, the iterator will contain objects only of that type (but not its subtypes). If a domain is provided, then the iterator will contain all objects of that type or any of its subtypes.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_objtypes-Tuple{State}","page":"Concepts and Data Types","title":"PDDL.get_objtypes","text":"Returns a map (dictionary, named tuple, etc.) from state objects to their types.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_objtype-Tuple{State, Any}","page":"Concepts and Data Types","title":"PDDL.get_objtype","text":"Returns the type of an object in a state.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_facts-Tuple{State}","page":"Concepts and Data Types","title":"PDDL.get_facts","text":"Returns an iterator over true Boolean predicates in a state.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_fluent-Tuple{State, Term}","page":"Concepts and Data Types","title":"PDDL.get_fluent","text":"Gets the value of a (non-derived) fluent.Equivalent to using the index notation state[term].\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.set_fluent!-Tuple{State, Any, Term}","page":"Concepts and Data Types","title":"PDDL.set_fluent!","text":"Sets the value of a (non-derived) fluent. Equivalent to using the index notation state[term] = val.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_fluents-Tuple{State}","page":"Concepts and Data Types","title":"PDDL.get_fluents","text":"Returns a map from fluent names to values (false predicates may be omitted). Base.pairs is an alias.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#Actions","page":"Concepts and Data Types","title":"Actions","text":"","category":"section"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"As described in the Getting Started, symbolic planning formalisms distinguish between action schemas (also known as operators), which specify the general semantics of an action, and ground actions,  which represent instantiations of an action schema for specific objects.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"An action schema comprises:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"A name that identifies the action.\nA list of (optionally typed) parameters or arguments that an action operates over.\nA precondition formula, defined over the parameters, that has to hold true for the action to be executable.\nAn effect formula, defined over the parameters, specifying how the action modifies the state once it is executed.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"note: Example\nAn example action schema definition in PDDL is shown below:(:action stack\n :parameters (?x ?y - block)\n :precondition (and (holding ?x) (clear ?y) (not (= ?x ?y)))\n :effect (and (not (holding ?x)) (not (clear ?y)) (clear ?x) (handempty) (on ?x ?y)))This schema defines the semantics of an action named stack and has two parameters of type block. Its precondition states that block ?x has to be held, block ?y has to be clear (no other block is on top of it), and that?x is not the same as ?y. Its effect states that in the next state, ?x will no longer be held, and that it will be instead be placed on top of block ?y.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"In PDDL.jl, action schemas are represented by the Action abstract type:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Action","category":"page"},{"location":"ref/datatypes/#PDDL.Action","page":"Concepts and Data Types","title":"PDDL.Action","text":"Action\n\nAbstract supertype for action schemas, which specify the general semantics of an action parameterized by a set of arguments.\n\n\n\n\n\n","category":"type"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"The following accessor methods are defined for an Action:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"PDDL.get_argvars(::Action)\nPDDL.get_argtypes(::Action)\nPDDL.get_precond(::Action)\nPDDL.get_effect(::Action)","category":"page"},{"location":"ref/datatypes/#PDDL.get_argvars-Tuple{Action}","page":"Concepts and Data Types","title":"PDDL.get_argvars","text":"Returns the argument variables for an action schema.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_argtypes-Tuple{Action}","page":"Concepts and Data Types","title":"PDDL.get_argtypes","text":"Returns the argument types for an action schema.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_precond-Tuple{Action}","page":"Concepts and Data Types","title":"PDDL.get_precond","text":"get_precond(action::Action)\nget_precond(action::Action, args)\nget_precond(domain::Domain, action::Term)\n\nReturns the precondition of an action schema as a Term, optionally parameterized by args. Alternatively, an action and its arguments can be specified as a Term.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_effect-Tuple{Action}","page":"Concepts and Data Types","title":"PDDL.get_effect","text":"get_effect(action::Action)\nget_effect(action::Action, args)\nget_effect(domain::Domain, action::Term)\n\nReturns the effect of an action schema as a Term, optionally parameterized by args. Alternatively, an action and its arguments can be specified as a Term.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Note that ground actions are represented with the Term data type rather than the Action data type, because the name property of a Term is sufficient to identify an action schema in the context of a planning domain, and the args property can be used to represent action parameters.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"There also exists a special no-op action schema, denoted PDDL.no_op in Julia code. The corresponding ground action can be expressed as pddl\"(--)\".","category":"page"},{"location":"ref/datatypes/#Domains","page":"Concepts and Data Types","title":"Domains","text":"","category":"section"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"A planning domain is a (first-order) symbolic model of the environment, specifying the predicates and functions that can be used to describe the environment, and the actions that can be taken in the environment, including their preconditions and effects. Some domains may also specify the types of objects that exist, or include domain axioms that specify which predicates can be derived from others.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"In PDDL.jl, domains are represented by the Domain abstract type:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Domain","category":"page"},{"location":"ref/datatypes/#PDDL.Domain","page":"Concepts and Data Types","title":"PDDL.Domain","text":"Domain\n\nAbstract supertype for planning domains, which specify a symbolic model of the environment and its transition dynamics.\n\n\n\n\n\n","category":"type"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"The following accessor methods are defined for a Domain:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"PDDL.get_name(::Domain)\nPDDL.get_typetree(::Domain)\nPDDL.get_types(::Domain)\nPDDL.get_subtypes(::Domain, ::Symbol)\nPDDL.get_predicates(::Domain)\nPDDL.get_predicate(::Domain, ::Symbol)\nPDDL.get_functions(::Domain)\nPDDL.get_function(::Domain, ::Symbol)\nPDDL.get_fluents(::Domain)\nPDDL.get_fluent(::Domain, ::Symbol)\nPDDL.get_axioms(::Domain)\nPDDL.get_axiom(::Domain, ::Symbol)\nPDDL.get_actions(::Domain)\nPDDL.get_action(::Domain, ::Symbol)","category":"page"},{"location":"ref/datatypes/#PDDL.get_name-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_name","text":"Returns the name of a domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_typetree-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_typetree","text":"Returns a map from domain types to subtypes.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_types-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_types","text":"Returns an iterator over types in the domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_subtypes-Tuple{Domain, Symbol}","page":"Concepts and Data Types","title":"PDDL.get_subtypes","text":"Returns an iterator over (immediate) subtypes of type in the domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_predicates-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_predicates","text":"Returns a map from predicate names to predicate signatures.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_predicate-Tuple{Domain, Symbol}","page":"Concepts and Data Types","title":"PDDL.get_predicate","text":"Returns the signature associated with a predicate name.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_functions-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_functions","text":"Returns a map from function names to function signatures.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_function-Tuple{Domain, Symbol}","page":"Concepts and Data Types","title":"PDDL.get_function","text":"Returns the signature associated with a function name.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_fluents-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_fluents","text":"Returns a map from domain fluent names to fluent signatures.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_fluent-Tuple{Domain, Symbol}","page":"Concepts and Data Types","title":"PDDL.get_fluent","text":"Returns the signature associated with a fluent name.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_axioms-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_axioms","text":"Returns a map from names of derived predicates to their corresponding axioms.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_axiom-Tuple{Domain, Symbol}","page":"Concepts and Data Types","title":"PDDL.get_axiom","text":"Returns the axiom assocated with a derived predicate name.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_actions-Tuple{Domain}","page":"Concepts and Data Types","title":"PDDL.get_actions","text":"Returns a map from action names to action schemata.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_action-Tuple{Domain, Symbol}","page":"Concepts and Data Types","title":"PDDL.get_action","text":"Returns the action schema specified by name.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#Problems","page":"Concepts and Data Types","title":"Problems","text":"","category":"section"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"A planning problem for a particular domain specifies both the initial state of the environment, and the task specification to be achieved. Typically, the task specification is a goal to be achieved, specified as a logical formula to be satisfied. However, planning problems can also include other specifications, such as a cost metric to minimize, and temporal constraints on the plan or state trajectory.","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"In PDDL.jl, problems are represented by the Problem abstract type:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"Problem","category":"page"},{"location":"ref/datatypes/#PDDL.Problem","page":"Concepts and Data Types","title":"PDDL.Problem","text":"Problem\n\nAbstract supertype for planning problems, which specify the initial state of a planning domain and the task specification to be achieved.\n\n\n\n\n\n","category":"type"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"The following accessor methods are defined for a Problem:","category":"page"},{"location":"ref/datatypes/","page":"Concepts and Data Types","title":"Concepts and Data Types","text":"PDDL.get_name(::Problem)\nPDDL.get_domain_name(::Problem)\nPDDL.get_objects(::Problem)\nPDDL.get_objtypes(::Problem)\nPDDL.get_init_terms(::Problem)\nPDDL.get_goal(::Problem)\nPDDL.get_metric(::Problem)\nPDDL.get_constraints(::Problem)","category":"page"},{"location":"ref/datatypes/#PDDL.get_name-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_name","text":"Returns the name of a problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_domain_name-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_domain_name","text":"Returns the name of a problem's domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_objects-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_objects","text":"Returns an iterator over objects in a problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_objtypes-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_objtypes","text":"Returns a map from problem objects to their types.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_init_terms-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_init_terms","text":"Returns a list of terms that determine the initial state.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_goal-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_goal","text":"Returns the goal specification of a problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_metric-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_metric","text":"Returns the metric specification of a problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/datatypes/#PDDL.get_constraints-Tuple{Problem}","page":"Concepts and Data Types","title":"PDDL.get_constraints","text":"Returns the constraint specification of a problem.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/speeding_up/#Speeding-Up-PDDL.jl","page":"Speeding Up PDDL.jl","title":"Speeding Up PDDL.jl","text":"","category":"section"},{"location":"tutorials/speeding_up/","page":"Speeding Up PDDL.jl","title":"Speeding Up PDDL.jl","text":"Coming soon!","category":"page"},{"location":"tutorials/writing_planners/#Writing-Planners","page":"Writing Planners","title":"Writing Planners","text":"","category":"section"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"Using the PDDL.jl interface, it is straightforward to implement planning algorithms which solve problems in PDDL domains. Since all domain and implementation specific details are encapsulated by the interface, the same algorithm can operate across multiple domains, and even multiple representations of the same domain (e.g. interpreted vs. compiled).","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"In this tutorial, we present two simple planners as examples: forward breadth-first search, and backward breadth-first search.","category":"page"},{"location":"tutorials/writing_planners/#Forward-Search","page":"Writing Planners","title":"Forward Search","text":"","category":"section"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"Our first example is forward breadth-first search, shown below. The algorithm accepts a Domain and Problem, then constructs the initial state with the initstate function. It also extracts the goal formula using PDDL.get_goal. The algorithm then searches the state space, iteratively expanding the successors of each state and available action in a breadth-first order:","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"function forward_bfs(domain::Domain, problem::Problem)\n    # Initialize state and extract goal\n    state = initstate(domain, problem)\n    goal = PDDL.get_goal(problem)\n    # Initialize search queue\n    plan = []\n    queue = [(state, plan)]\n    while length(queue) > 0\n        # Pop state and plan\n        state, plan = popfirst!(queue)\n        # Check if goal is satisfied\n        if satisfy(domain, state, goal)\n            # Return plan if goal is satisfied\n            return plan\n        end\n        # Iterate over available actions and add successors to queue\n        for action in available(domain, state)\n            next_state = transition(domain, state, action)\n            next_plan = [plan; action]\n            push!(queue, (next_state, next_plan))\n        end\n    end\n    # Return nothing upon failure\n    return nothing\nend","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"As can be seen, search proceeds by popping a state and corresponding plan off the search queue at each iteration, then checking if the state satisfies the goal using satisfy. If the goal is satisfied, the plan is returned. If not, the state is expanded by iterating over each available action, and constructing the successor state for that action using the transition function. The successor state and its corresponding plan are added to queue. Search continues until either the queue is exhausted, or the goal is satisfied.","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"note: Implementation Efficiency\nWhile easy to understand, the implementation of breadth-first search presented here is memory inefficient because it stores the plan to each state as part of the search queue. Efficient implementations of planners using breadth-first search should be based off Djikstra's algorithm instead.","category":"page"},{"location":"tutorials/writing_planners/#Regression-Search","page":"Writing Planners","title":"Regression Search","text":"","category":"section"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"PDDL.jl also supports planning via backward search, also known as regression search. Backward search operates by treating the goal condition as a partial or abstract state which only specifies that some predicates must be true. It then searches the space by considering all actions that could possibly achieve the current abstract state (called relevant actions), and inverting the semantics of each action (called regression). This results in a successor abstract state that represents the pre-image of the action: the set of all states that could have reached the current abstract state through that action.","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"A breadth-first version of backward search is shown below.","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"function backward_bfs(domain::Domain, problem::Problem)\n    # Construct initial state and goal state\n    init_state = initstate(domain, problem)\n    state = goalstate(domain, problem)\n    # Initialize search queue\n    plan = []\n    queue = [(state, plan)]\n    while length(queue) > 0\n        # Pop state and plan\n        state, plan = popfirst!(queue)\n        # Return plan if initial state implies the current abstract state\n        if all(evaluate(domain, init_state, fluent) == val\n               for (fluent, val) in PDDL.get_fluents(state))\n            return plan\n        end\n        # Iterate over relevant actions and add pre-image to queue\n        for action in relevant(domain, state)\n            next_state = regress(domain, state, action)\n            next_plan = [action; plan]\n            push!(queue, (next_state, next_plan))\n        end\n    end\n    # Return nothing upon failure\n    return nothing\nend","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"This algorithm is very similar to forward_bfs: It first constructs an initial state (using initstate) and abstract goal state (using goalstate) from the domain and problem. It then searches in a breadth-first order from the abstract goal state, iterating over actions that are relevant to achieving the current abstract state, then computing the preimage induced by each action using regress and adding the resulting state to the queue. The search terminates when the initial state is found to be in the preimage of some action, i.e., all fluents that are true in the preimage are also true in the initial state.","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"note: Support for Regression Search\nPDDL.jl currently only provides correct implementations of regression search operations (relevant and regress) for STRIPS-style domains. This means that regression search is not currently supported for domains with non-Boolean fluents, negative preconditions, disjunctive preconditions, quantified preconditions, or conditional effects.","category":"page"},{"location":"tutorials/writing_planners/#Existing-Planners","page":"Writing Planners","title":"Existing Planners","text":"","category":"section"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"While PDDL.jl makes it relatively easy to implement planning algorithms from scratch, the performance and (re)usability of these algorithms require more careful design. As such, the PDDL.jl ecosystem also includes the SymbolicPlanners.jl library, which provides a wide array of planning algorithms and heuristics that have comparable performance to other commonly-used planning systems. Below, we show how to use SymbolicPlanners.jl to solve a Blocksworld problem via A* search with the additive heuristic:","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"using PDDL, PlanningDomains, SymbolicPlanners\n\n# Load Blocksworld domain and problem\ndomain = load_domain(:blocksworld)\nproblem = load_problem(:blocksworld, \"problem-4\")\nstate = initstate(domain, problem)\ngoal = PDDL.get_goal(problem)\n\n# Construct A* planner with h_add heuristic\nplanner = AStarPlanner(HAdd())\n\n# Solve the problem using the planner\nsol = planner(domain, state, goal)","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"We can check that the resulting solution achieves the goal as desired:","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"julia> goal\nand(on(d, c), on(c, b), on(b, a), on(a, e))\n\njulia> collect(sol)\n10-element Vector{Any}:\n unstack(b, a)\n put-down(b)\n unstack(a, d)\n stack(a, e)\n pick-up(b)\n stack(b, a)\n pick-up(c)\n stack(c, b)\n pick-up(d)\n stack(d, c)\n\njulia> satisfy(domain, sol.trajectory[end], goal)\ntrue","category":"page"},{"location":"tutorials/writing_planners/","page":"Writing Planners","title":"Writing Planners","text":"For more information about the planners and heuristics provided by SymbolicPlanners.jl, consult the README.","category":"page"},{"location":"tutorials/extending/#Extending-PDDL.jl","page":"Extending PDDL.jl","title":"Extending PDDL.jl","text":"","category":"section"},{"location":"tutorials/extending/","page":"Extending PDDL.jl","title":"Extending PDDL.jl","text":"Coming soon!","category":"page"},{"location":"ref/parser_writer/#Parser-and-Writer","page":"Parser and Writer","title":"Parser and Writer","text":"","category":"section"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"PDDL.jl supports both parsing and writing of PDDL files and strings. In addition, the parser is designed to be extensible, allowing variants or extensions of PDDL to be easily supported.","category":"page"},{"location":"ref/parser_writer/#General-Parsing","page":"Parser and Writer","title":"General Parsing","text":"","category":"section"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"The PDDL.Parser submodule contains all functionality related to parsing PDDL strings and loading of PDDL files. To parse a string in PDDL, use the macro @pddl or the function parse_pddl. Both of these return a list of parsed results if multiple strings are provided.","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"@pddl\nparse_pddl","category":"page"},{"location":"ref/parser_writer/#PDDL.Parser.@pddl","page":"Parser and Writer","title":"PDDL.Parser.@pddl","text":"Parse string(s) to PDDL construct.\n\n\n\n\n\n","category":"macro"},{"location":"ref/parser_writer/#PDDL.Parser.parse_pddl","page":"Parser and Writer","title":"PDDL.Parser.parse_pddl","text":"Parse to PDDL structure based on initial keyword.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"Below we use @pddl to parse a sequence of predicates, and use parse_pddl to parse a PDDL axiom (a.k.a. derived predicate):","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"julia> @pddl(\"(on a b)\", \"(on b c)\")\n2-element Vector{Compound}:\n on(a, b)\n on(b, c)\njulia> parse_pddl(\"(:derived (handempty) (forall (?x) (not (holding ?x))))\")\nhandempty <<= forall(object(X), not(holding(X)))","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"In addition, there exists a string macro pddl\"...\", which is ideal for parsing single string literals:","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"julia> pddl\"(on a b)\"\non(a, b)","category":"page"},{"location":"ref/parser_writer/#Parsing-Domains-and-Problems","page":"Parser and Writer","title":"Parsing Domains and Problems","text":"","category":"section"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"To parse domains and problems specified as PDDL strings, use parse_domain and parse_problem.","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"parse_domain\nparse_problem","category":"page"},{"location":"ref/parser_writer/#PDDL.Parser.parse_domain","page":"Parser and Writer","title":"PDDL.Parser.parse_domain","text":"Parse PDDL domain description.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/#PDDL.Parser.parse_problem","page":"Parser and Writer","title":"PDDL.Parser.parse_problem","text":"Parse PDDL problem description.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"To load domains or problems from a file, use load_domain and load_problem.","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"load_domain\nload_problem","category":"page"},{"location":"ref/parser_writer/#PDDL.Parser.load_domain","page":"Parser and Writer","title":"PDDL.Parser.load_domain","text":"load_domain(path::AbstractString)\nload_domain(io::IO)\n\nLoad PDDL domain from specified path or IO object.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/#PDDL.Parser.load_problem","page":"Parser and Writer","title":"PDDL.Parser.load_problem","text":"load_problem(path::AbstractString)\nload_problem(io::IO)\n\nLoad PDDL problem from specified path or IO object.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/#Extending-the-Parser","page":"Parser and Writer","title":"Extending the Parser","text":"","category":"section"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"The parser can be extended to handle new PDDL constructs using the following macros:","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"PDDL.Parser.@add_top_level\nPDDL.Parser.@add_header_field\nPDDL.Parser.@add_body_field","category":"page"},{"location":"ref/parser_writer/#PDDL.Parser.@add_top_level","page":"Parser and Writer","title":"PDDL.Parser.@add_top_level","text":"@add_top_level(name, f)\n\nRegister f as a top-level parser for PDDL descriptions (e.g domains, problems).\n\n\n\n\n\n","category":"macro"},{"location":"ref/parser_writer/#PDDL.Parser.@add_header_field","page":"Parser and Writer","title":"PDDL.Parser.@add_header_field","text":"@add_header_field(desc, fieldname, f)\n\nRegister f as a parser for a header field in a PDDL description.\n\n\n\n\n\n","category":"macro"},{"location":"ref/parser_writer/#PDDL.Parser.@add_body_field","page":"Parser and Writer","title":"PDDL.Parser.@add_body_field","text":"@add_body_field(desc, fieldname, f)\n\nRegister f as a parser for a body field in a PDDL description.\n\n\n\n\n\n","category":"macro"},{"location":"ref/parser_writer/#General-Writing","page":"Parser and Writer","title":"General Writing","text":"","category":"section"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"The PDDL.Writer submodule contains all functionality related to writing PDDL strings and saving of PDDL files. To write a string in PDDL syntax, use the function write_pddl.","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"write_pddl","category":"page"},{"location":"ref/parser_writer/#PDDL.Writer.write_pddl","page":"Parser and Writer","title":"PDDL.Writer.write_pddl","text":"Write to string in PDDL syntax.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"Below we use write_pddl to write out an Action from the Blocksworld domain.","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"julia> write_pddl(PDDL.get_action(domain, :stack)) |> print\n(:action stack\n :parameters (?x ?y - block)\n :precondition (and (holding ?x) (clear ?y) (not (= ?x ?y)))\n :effect (and (not (holding ?x)) (not (clear ?y)) (clear ?x) (handempty) (on ?x ?y)))","category":"page"},{"location":"ref/parser_writer/#Writing-Domains-and-Problems","page":"Parser and Writer","title":"Writing Domains and Problems","text":"","category":"section"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"To write domains and problem as PDDL strings, use write_domain and write_problem.","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"write_domain\nwrite_problem","category":"page"},{"location":"ref/parser_writer/#PDDL.Writer.write_domain","page":"Parser and Writer","title":"PDDL.Writer.write_domain","text":"Write domain in PDDL syntax.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/#PDDL.Writer.write_problem","page":"Parser and Writer","title":"PDDL.Writer.write_problem","text":"Write problem in PDDL syntax.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"To save domains or problems as text files to a path, use save_domain and save_problem.","category":"page"},{"location":"ref/parser_writer/","page":"Parser and Writer","title":"Parser and Writer","text":"save_domain\nsave_problem","category":"page"},{"location":"ref/parser_writer/#PDDL.Writer.save_domain","page":"Parser and Writer","title":"PDDL.Writer.save_domain","text":"save_domain(path::String, domain::Domain)\n\nSave PDDL domain to specified path.\n\n\n\n\n\n","category":"function"},{"location":"ref/parser_writer/#PDDL.Writer.save_problem","page":"Parser and Writer","title":"PDDL.Writer.save_problem","text":"save_problem(path::String, problem::Problem)\n\nSave PDDL problem to specified path.\n\n\n\n\n\n","category":"function"},{"location":"ref/interpreter/#Interpreter","page":"Interpreter","title":"Interpreter","text":"","category":"section"},{"location":"ref/interpreter/","page":"Interpreter","title":"Interpreter","text":"Coming soon!","category":"page"},{"location":"tutorials/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Welcome to using PDDL.jl! This tutorial covers how to install PDDL.jl, how to load your first domain and problem, how to manipulate and inspect states and actions, and how to write and execute a plan that achieves a goal.","category":"page"},{"location":"tutorials/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"First, download and run Julia, available here (version 1.3 or later required). Optionally, create your own project and activate its environment. Next, press ] in the Julia REPL to enter the package manager, then install the registered version of PDDL.jl by running:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"add PDDL","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"To install the latest development version, you may instead run:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"add https://github.com/JuliaPlanners/PDDL.jl.git","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"PDDL.jl can now be used in the Julia REPL, or at the top of a script:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"using PDDL","category":"page"},{"location":"tutorials/getting_started/#Loading-Domains-and-Problems","page":"Getting Started","title":"Loading Domains and Problems","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"PDDL stands for the Planning Domain Definition Language, a formal language for specifying the semantics of planning domains and problems. PDDL domain and problem definitions are typically saved as text files with the .pddl extension.","category":"page"},{"location":"tutorials/getting_started/#Loading-Domains","page":"Getting Started","title":"Loading Domains","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"A PDDL domain defines the high-level \"physics\" or transition dynamics of a planning task. A classic example is Blocksworld, a domain where blocks may be stacked on top of each other, or placed on a table:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"(define (domain blocksworld)\n  (:requirements :strips :typing :equality)\n  (:types block)\n  (:predicates (on ?x ?y - block) (ontable ?x - block) (clear ?x - block)\n               (handempty) (holding ?x - block))\n  (:action pick-up\n   :parameters (?x - block)\n   :precondition (and (clear ?x) (ontable ?x) (handempty))\n   :effect (and (not (ontable ?x)) (not (clear ?x))\n                (not (handempty))  (holding ?x)))\n  (:action put-down\n   :parameters (?x - block)\n   :precondition (holding ?x)\n   :effect (and (not (holding ?x)) (clear ?x)\n                (handempty) (ontable ?x)))\n  (:action stack\n   :parameters (?x ?y - block)\n   :precondition (and (holding ?x) (clear ?y) (not (= ?x ?y)))\n   :effect (and (not (holding ?x)) (not (clear ?y)) (clear ?x)\n                (handempty) (on ?x ?y)))\n  (:action unstack\n   :parameters (?x ?y - block)\n   :precondition (and (on ?x ?y) (clear ?x) (handempty) (not (= ?x ?y)))\n   :effect (and (holding ?x) (clear ?y) (not (clear ?x))\n                (not (handempty)) (not (on ?x ?y))))\n)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Suppose this domain definition is saved in a file named blocksworld.pddl in the current directory. After loading PDDL.jl with using PDDL, we can load the Blocksworld domain by calling load_domain:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"domain = load_domain(\"blocksworld.pddl\")","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can then inspect the name of domain, and the list of action names:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_name(domain)\n:blocksworld\n\njulia> PDDL.get_actions(domain) |> keys .|> string\n4-element Vector{String}:\n \"pick-up\"\n \"unstack\"\n \"put-down\"\n \"stack\"","category":"page"},{"location":"tutorials/getting_started/#Loading-Problems","page":"Getting Started","title":"Loading Problems","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"PDDL domains only define the general semantics of the planning task that apply across any set of objects or goals. To fully define a planning task, we also need to load a PDDL problem, which defines an initial state, and a goal to be achieved:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"(define (problem blocksworld-problem)\n  (:domain blocksworld)\n  (:objects a b c - block)\n  (:init (handempty) (ontable a) (ontable b) (ontable c)\n         (clear a) (clear b) (clear c))\n  (:goal (and (clear c) (ontable b) (on c a) (on a b)))\n)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"In this problem, there are 3 blocks, a, b, and c, which are all initially placed on the table (ontable), with no other blocks placed on them (clear). The goal is to stack the blocks such that c is on a is on b.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Suppose the problem definition is saved in blocksworld-problem.pddl. We can load it by calling load_problem:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"problem = load_problem(\"blocksworld-problem.pddl\")","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can then inspect the list of objects, and the goal to be reached:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_objects(problem) |> println\nConst[a, b, c]\n\njulia> PDDL.get_goal(problem) |> write_pddl\n\"(and (clear c) (ontable b) (on c a) (on a b))\"","category":"page"},{"location":"tutorials/getting_started/#Loading-From-A-Repository","page":"Getting Started","title":"Loading From A Repository","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"A wide variety of standard PDDL domains and problems can be found online, such as this repository of instances from the International Planning Competition (IPC). To ease the (down)loading of these domains and problems, the PDDL.jl ecosystem includes PlanningDomains.jl, which contains both a built-in repository of domains and problems, and an interface for accessing domains and problems from other online repositories.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"PlanningDomains.jl can be installed from the Pkg REPL as per usual:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"add PlanningDomains","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Once installed, we can use PlanningDomains.jl to directly load Blocksworld domains and problems:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"using PlanningDomains\n\ndomain = load_domain(:blocksworld)\nproblem = load_problem(:blocksworld, \"problem-2\")","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can also specify external repositories to download from, such as the previously mentioned repository of IPC domains and problems:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"domain = load_domain(IPCInstancesRepo, \"ipc-2000\", \"blocks-strips-typed\")\nproblem = load_problem(IPCInstancesRepo, \"ipc-2000\", \"blocks-strips-typed\", \"problem-2\")","category":"page"},{"location":"tutorials/getting_started/#Constructing-and-Inspecting-States","page":"Getting Started","title":"Constructing and Inspecting States","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now that we've loaded a domain and problem, we can construct the initial state (specified by the problem file) using the initstate function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"state = initstate(domain, problem)","category":"page"},{"location":"tutorials/getting_started/#Inspecting-Facts-and-Relations","page":"Getting Started","title":"Inspecting Facts and Relations","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Conceptually, a state consists of a set of objects, and a set of true facts and relations about those objects. We can list the set of facts using PDDL.get_facts:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_facts(state)\nSet{Term} with 7 elements:\n  clear(a)\n  ontable(b)\n  clear(b)\n  handempty\n  ontable(a)\n  ontable(c)\n  clear(c)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: PDDL vs. Prolog-style syntax\nFacts are printed in Prolog-style syntax by default: ontable(a) in Prolog is the same as (ontable a) in PDDL. This is because PDDL.jl uses Julog.jl to represent terms and expressions in first-order logic.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"In addition to listing facts, we can query the truth value of specific terms using the satisfy function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> satisfy(domain, state, pddl\"(ontable a)\")\ntrue\n\njulia> satisfy(domain, state, pddl\"(on a b)\")\nfalse","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Here, we used the pddl string macro to construct a first-order Term. This allows us to write pddl\"(on a b)\" as syntactic sugar for the expression Compound(:on, Term[Const(:a), Const(:b)]).","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Besides querying whether particular terms are true or false, we can also ask PDDL.jl to return all satisfying assignments to a logical formula with free variables using the satisfiers function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> satisfiers(domain, state, pddl\"(and (ontable ?x) (clear ?x))\")\n3-element Vector{Any}:\n {X => b}\n {X => a}\n {X => c}","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Our query pddl\"(and (ontable ?x) (clear ?x))\" expresses that some object ?x is on the table, and is clear (i.e. has no other blocks on top of it), where ?x is PDDL syntax for a variable in a first-order formula. Since blocks a, b and c all satisfy the query, satisfiers returns a list of corresponding variable substitutions. Note that the PDDL variable ?x gets rendered in Prolog-style syntax as a capital X, by the convention in Prolog that capital letters refer to variables.","category":"page"},{"location":"tutorials/getting_started/#Inspecting-Non-Boolean-Fluents","page":"Getting Started","title":"Inspecting Non-Boolean Fluents","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"PDDL is not limited to domains where object properties and relations must have Boolean values. For example, the Zeno Travel domain includes numeric properties and relations, such as the distance between two cities, or the amount of fuel in a plane. We can construct and inspect a state in this domain as well:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"zt_domain = load_domain(:zeno_travel)\nzt_problem = load_problem(:zeno_travel, \"problem-1\")\nzt_state = initstate(zt_domain, zt_problem)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"To inspect all properties and relations (Boolean or otherwise) in this state, we can iterate over the list of pairs returned by PDDL.get_fluents:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_fluents(zt_state) |> collect\n13-element Vector{Pair}:\n  at(plane1, city0) => true\n at(person1, city0) => true\n    onboard(plane1) => 0\n  slow-burn(plane1) => 4\n                    ⋮\n       fuel(plane1) => 3956\n  fast-burn(plane1) => 15\n zoom-limit(plane1) => 8\n   capacity(plane1) => 10232","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"These properties and relations are called fluents, a term historically used in AI research to describe facts about the world that may change over time.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Fluents are sometimes also called \"state variables\", but we avoid that terminology to prevent confusion with variables in the context of first-order terms and formulae. In keeping with the terminology of first-order logic, Boolean fluents such as (at ?plane ?city) are also called predicates, and non-Boolean fluents such as (fuel ?plane) are called functions (because they map objects to values).","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Omitted Predicates\nFor conciseness, some implementations of the PDDL.jl interface will omit predicates that are false from the list returned by PDDL.get_fluents, as is the case above.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"In addition to listing fluents, we can evaluate specific fluents using the evaluate function. Below, we query the amount of fuel in plane1:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> evaluate(zt_domain, zt_state, pddl\"(fuel plane1)\")\n3956","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can also evaluate compound expressions of multiple fluents. For example, we might be curious to know the amount of additional fuel that plane1 can hold. As syntactic sugar for evaluate(domain, state, term), we can also use the syntax domain[state => term]:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> evaluate(zt_domain, zt_state, pddl\"(- (capacity plane1) (fuel plane1))\")\n6276\n\njulia> zt_domain[zt_state => pddl\"(- (capacity plane1) (fuel plane1))\"]\n6276","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"For non-compound expressions stored directly in the state, we can use PDDL.get_fluent to look up the value of a term in state, or state[term] for short:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> state[pddl\"(on a b)\"] # Blocksworld query\nfalse\n\njulia> zt_state[pddl\"(fuel plane1)\"] # Zeno Travel query\n3956","category":"page"},{"location":"tutorials/getting_started/#Inspecting-Objects-and-Object-Types","page":"Getting Started","title":"Inspecting Objects and Object Types","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Since PDDL states consist of sets of (optionally typed) objects, PDDL.jl provides the PDDL.get_objects function to list all objects in a state, as well as all objects of particular type:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_objects(state) |> println # Blocksworld objects\nConst[c, a, b]\n\njulia> PDDL.get_objects(zt_state, :aircraft) |> println # Zeno Travel aircraft\nConst[plane1]\n\njulia> PDDL.get_objects(zt_domain, zt_state, :movable) |> println # Zeno Travel movables\nConst[person1, plane1]","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that in the third call to PDDL.get_objects, we also provided the domain as the first argument. This is because the domain stores information about the type hierarchy, and the movable type in the Zeno Travel domain is abstract: There are no objects in the state which have the type movable. There only objects of its subtypes, person and aircraft. We can inspect the type hierarchy of a domain using PDDL.get_typetree:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_typetree(zt_domain)\nDict{Symbol, Vector{Symbol}} with 5 entries:\n  :object   => [:movable, :city]\n  :movable  => [:aircraft, :person]\n  :aircraft => []\n  :person   => []\n  :city     => []","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, we can inspect the type of a specific object using PDDL.get_objtype:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_objtype(zt_state, pddl\"(person1)\")\n:person","category":"page"},{"location":"tutorials/getting_started/#Executing-Actions-and-Plans","page":"Getting Started","title":"Executing Actions and Plans","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"PDDL domains not only define the predicates and functions which describe a state, but also a set of actions which can modify a state. Having learned how to inspect the contents of a state, we can now modify them using actions.","category":"page"},{"location":"tutorials/getting_started/#Instantiating-Actions","page":"Getting Started","title":"Instantiating Actions","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"In PDDL and symbolic planning more broadly, we distinguish between action schemas (also known as operators), which specify the general semantics of an action, and ground actions, which represent instantiations of actions for specific objects. We can inspect the definition of an action schema in a domain using PDDL.get_action, such as the definition of stack below:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PDDL.get_action(domain, :stack) |> write_pddl |> print\n(:action stack\n :parameters (?x ?y - block)\n :precondition (and (holding ?x) (clear ?y) (not (= ?x ?y)))\n :effect (and (not (holding ?x)) (not (clear ?y)) (clear ?x) (handempty) (on ?x ?y)))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"The stack schema has two parameters (or arguments) of type block. This means that ground instances of the stack schema have to be applied to two block objects. The schema also specifies a precondition formula, which has to hold true in order for the action to be executable (a.k.a. available) in the current state. Finally, the schema contains an effect formula, which specifies facts that will either be added or deleted in the next state. In domains with non-Boolean fluents, effects may also assign or modify the values of fluents.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"To refer to a specific application of this action schema to blocks a and b (i.e., a ground action), we can simply write pddl\"(stack a b)\", which constructs a Term with stack as its name, and with a and b as arguments:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> pddl\"(stack a b)\" |> dump\nCompound\n  name: Symbol stack\n  args: Array{Term}((2,))\n    1: Const\n      name: Symbol a\n    2: Const\n      name: Symbol b","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"If unspecified, whether we are referring to action schemas or ground actions shall be clear from context.","category":"page"},{"location":"tutorials/getting_started/#Listing-Available-Actions","page":"Getting Started","title":"Listing Available Actions","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"For our initial state in the Blocksworld domain, we can iterate over the list of available ground actions (i.e. those with satisfied preconditions) using the available function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> available(domain, state) |> collect\n3-element Vector{Compound}:\n pick-up(a)\n pick-up(b)\n pick-up(c)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that available returns an iterator over such actions, so we have to collect this iterator in order to get a Vector result. As before, action Terms are printed in Prolog-style syntax.","category":"page"},{"location":"tutorials/getting_started/#Executing-Actions","page":"Getting Started","title":"Executing Actions","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Since we now know which actions are available, we can execute one of them to get another state:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> next_state = execute(domain, state, pddl\"(pick-up a)\");\n\njulia> satisfy(domain, next_state, pddl\"(holding a)\")\ntrue","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"We see that after executing the pddl\"(pick-up a)\" action, block a is now being held. In contrast, if we try to execute a non-available action, PDDL.jl will throw an error:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> next_state = execute(domain, state, pddl\"(stack a b)\");\nERROR: Precondition (and (holding ?x) (clear ?y) (not (= ?x ?y))) does not hold.\n⋮","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Instead of using execute, we can also use the transition function. For domains written in standard PDDL, these functions have the same behavior, but there are extensions of PDDL which include events and processes that are handled by transition only. Note that both execute and transition do not mutate the original state passed in as an argument. For mutating versions, see execute! and transition!.","category":"page"},{"location":"tutorials/getting_started/#Executing-and-Simulating-Plans","page":"Getting Started","title":"Executing and Simulating Plans","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now that we know how to execute an action, we can execute a series of actions (i.e. a plan) to achieve our goal in the Blocksworld domain. We can do this by repeatedly calling  transition:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"state = initstate(domain, problem)\nstate = transition(domain, state, pddl\"(pick-up a)\")\nstate = transition(domain, state, pddl\"(stack a b)\")\nstate = transition(domain, state, pddl\"(pick-up c)\");\nstate = transition(domain, state, pddl\"(stack c a)\");","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"And then check that our goal is indeed satisfied:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> goal = PDDL.get_goal(problem) # Our goal is stack `c` on `a` on `b`\nand(clear(c), ontable(b), on(c, a), on(a, b))\n\njulia> satisfy(domain, state, goal)\ntrue","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Rather than repeatedly call transition, we can use the PDDL.simulate function to directly simulate the end result of a sequence of actions:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"state = initstate(domain, problem)\nplan = @pddl(\"(pick-up a)\", \"(stack a b)\", \"(pick-up c)\", \"(stack c a)\")\nend_state = PDDL.simulate(EndStateSimulator(), domain, state, plan)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"As before, the goal is satisfied in the final state:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> satisfy(domain, end_state, goal)\ntrue","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"The first argument to PDDL.simulate is a concrete instance of a Simulator, which controls what information is collected as the simulation progresses. By default, the first argument is a StateRecorder, which leads PDDL.simulate to return the trajectory of all states encountered, including the first:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> traj = PDDL.simulate(domain, state, plan);\n\njulia> eltype(traj)\nGenericState\n\njulia> length(traj)\n5","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"You've now learned how to load PDDL domains and problems, construct and inspect states, and execute (sequences of) actions – congratulations! In the next tutorial, you can learn how to write your very own planning algorithms using the functions introduced here.","category":"page"},{"location":"#PDDL.jl","page":"PDDL.jl","title":"PDDL.jl","text":"","category":"section"},{"location":"","page":"PDDL.jl","title":"PDDL.jl","text":"A extensible and performant interface for symbolic planning domains specified in the Planning Domain Definition Language (PDDL), with support for PDDL parsing, interpretation, and compilation.","category":"page"},{"location":"#Features","page":"PDDL.jl","title":"Features","text":"","category":"section"},{"location":"","page":"PDDL.jl","title":"PDDL.jl","text":"Parsing and writing of PDDL domain and problem files\nA high-level symbolic planning API for use by algorithms and applications\nExecution of PDDL actions and plans\nAbstract interpretation of PDDL semantics\nDomain grounding and compilation for increased performance\nSemantic extensibility through modular theories","category":"page"},{"location":"","page":"PDDL.jl","title":"PDDL.jl","text":"PDDL.jl does not include any planning algorithms. Rather, it provides an interface so that planners for PDDL domains can easily be written, as in SymbolicPlanners.jl.","category":"page"},{"location":"#Tutorials","page":"PDDL.jl","title":"Tutorials","text":"","category":"section"},{"location":"","page":"PDDL.jl","title":"PDDL.jl","text":"Learn how to install and use PDDL.jl by following these tutorials:","category":"page"},{"location":"","page":"PDDL.jl","title":"PDDL.jl","text":"Pages = [\n    \"tutorials/getting_started.md\",\n    \"tutorials/writing_planners.md\",\n    \"tutorials/speeding_up.md\",\n    \"tutorials/extending.md\"\n]\nDepth = 1","category":"page"},{"location":"#Architecture-and-Interface","page":"PDDL.jl","title":"Architecture and Interface","text":"","category":"section"},{"location":"","page":"PDDL.jl","title":"PDDL.jl","text":"Learn about the architecture of PDDL.jl, its high-level interface for symbolic planning, and the built-in implementations of this interface:","category":"page"},{"location":"","page":"PDDL.jl","title":"PDDL.jl","text":"Pages = [\n    \"ref/overview.md\",\n    \"ref/datatypes.md\",\n    \"ref/interface.md\",\n    \"ref/parser_writer.md\",\n    \"ref/interpreter.md\",\n    \"ref/compiler.md\",\n    \"ref/absint.md\",\n    \"ref/utilities.md\"\n]\nDepth = 1","category":"page"}]
}
